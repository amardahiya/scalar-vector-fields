======= Plotting of scalar and vector fields =======

Visualization of two-dimensional scalar and vector fields will here
be done by using three different
packages: Matplotlib, SciTools, and Mayavi. The latter contains
support for doing more advanced plotting operations in three
dimensions.  The three packages are different in many respects, but
they also have much in common, as code below shows.  Note that (for
most backends one can plug into Matplotlib, SciTools, and Mayavi) one
can rotate a figure by holding the mouse cursor down. This
functionality is often useful in order to get a better view of a
three-dimensional plot.

For Ubuntu,
Section ref{sec:accesspy:vmware} describes installation of all the software
needed for plotting with the mentioned packages.
For Python programming on Mac OSX and Windows, we recommend using Anaconda. To obtain an environment for this, download the file `inf11003dplot.txt` from the bookâ€™s webpage,
and then create a conda environment named `inf11003dplot` with contents described in this file. This can be done by writing

!bc sys
conda create --name inf11003dplot --file inf11003dplot.txt
!ec
Then one has to activate the environment. The syntax for this depends on the platform:

!bc sys
source activate inf11003dplot # Mac OSX platforms
activate inf11003dplot        # Windows platforms
!ec

Our pedagogical example consists of plotting a scalar function in different ways.
we will flat create contour plots as well as an elevated three-dimensional
surface, and also plot the latter together with a parametrized curve lying
on the surface. To illustrate plotting of
vector fields, we simply plot the gradient of the scalar field, but will
also illustrate two- and a three-dimensional vector fields
unrelated to a surface.
Before we start, let us be clear on how variable names have bene chosen.

* We have used names such as `x`, `y`, `z` for one-dimensional coordinates.
* We have used names such as `xv`, `yv`, `zv` for vectorized coordinates in a higher dimensional grid.
* For vector fields, we use names such as `u`, `v`, `w` for vectors at points corresponding to `xv`, `yv`, `zv`.

Below are more mathematical details on the various scalar and vector fields
we aim to plot.

===== Surface plots =====

We consider the surface defined by

!bt
\begin{equation}
h(x,y) = \frac{h_0}{1+ \frac{x^2+y^2}{R^2}},
label{heq}
\end{equation}
!et
$h(x,y)$ may model the height of an isolated circular mountain, $h$ being the height above sea level, while $x$ and $y$ are Cartesian coordinates, $h_0$ is the height at the top of the mountain, and $R$ what is the radius of the mountain.
Since mountains are actually quite flat (or more precisely,
their heights are small compared to the horizontal extent), we use
meter as length unit for vertical distances ($z$ direction) and km as length
unit for horizontal distances ($x$ and $y$ coordinates).
Prior to all code below we have initialized $h_0$ and $R$ with
the following values:

@@@CODE plot3d_matplotlib.py fromto: h0 =@#endinitvalues

===== Grid for two-dimensional fields =====

Before we can plot $h(x,y)$, we need to create a rectangular grid in the $xy$ plane with all the points used for plotting. Regardless of which plotting package we will use later on, the grid can be created as follows:

@@@CODE plot3d_matplotlib.py fromto: # Grid for x, y@# endinitgrid
The grid is based on equally spaced coordinates `x` and `y` in the
intercal $[-10,10]$ km.
Note the mysterious extra parameters to `meshgrid` here, which are needed in order for the coordinates to have the right order in mathematics.
In Figure ref{plotmatplotlib} we have shown two plots of the surface $h(x,y)$, created with Matplotlib. Section ref{matplotlibsurfaceplots} presents the code which generates these plots.

FIGURE:[fig/plot_matplotlib] Plot of a mountain: contours without colors (left) and with colors (right), shown together with a curve showing a trajectory to the top of the mountain. label{plotmatplotlib}

[hpl: Figure ref{plotmatplotlib} looks strange: with and without colors does not make sense... It is just a bit more red in the right figure. The trajectory is very difficult to see. It is just not a good illustration...]

===== Parametrized curve =====

To illustrate the plotting of three-dimensional parameterized curves,
we consider a trajectory that represents a circular climb to the top
of the mountain:

!bt
\begin{equation}
\bm{r}(t) = \left( 10\left(1 - \frac{t}{2\pi}\right)\cos(t) \right) \bm{i} + \left( 10\left(1 - \frac{t}{2\pi}\right)\sin(t) \right) \bm{j} + \frac{h_0}{1 + \frac{100(1 - t/(2\pi))^2}{R^2}} \bm{k}. label{req}
\end{equation}
!et
Here $\bm{i}$, $\bm{j}$, and $\bm{k}$ denote the unit vectors in the $x$-, $y$-, and $z$-directions, respectively.
The coordinates of this parametrized curve $\bm{r}(t)$ can be produced by

@@@CODE plot3d_matplotlib.py fromto: s = np.linspace@# endparamcurve
The parametric curve is shown together with the surface $h(x,y)$ in the right plot in Figure ref{plotmatplotlib}.



===== The gradient vector field =====

The gradient vector field $\nabla h$ of $h(x,y)$ is defined as

!bt
\begin{equation}
\nabla h = \frac{\partial h}{\partial x}\bm{i} +  \frac{\partial h}{\partial y}\bm{j}.
label{gradienteq}
\end{equation}
!et
One learns in vector calculus
that the gradients are orthogonal to the contour lines.
This is something we can easily illustrate in our plots when when we combine the
contour plot with a plot of the gradient vector field.
[hpl: This does not make sense since we have not talked about contour lines
yet. They are defined later.]

When we plot the gradient vector field, it is useful to make a grid of coordinates with a smaller resolution that what we use for the surface coordinates.
The reason is that an arrow is drawn at each point in the grid, and
if the resolution is too high, the arrows will collide and result in
a cluttered plot that is difficult to interpret.
So, let us use a grid with 20 instead of 40 intervals in the horizontal
directions:

@@@CODE plot3d_matplotlib.py fromto: # Define a coarser grid for the vector field@# endcoarsergrid
The gradient vector field of $h(x,y)$ can now be computed using the function `np.gradient`:

@@@CODE plot3d_matplotlib.py fromto: dhdx, dhdy@# endgradient
The gradient field (ref{gradienteq}) appears in Figure ref{quivermatplotlib}.
Section ref{matplotlibquiverplots} explains the code needed to make these
plots.

FIGURE:[fig/quiver_matplotlib, width=600 frac=0.8] 2D vector field (left), combined with contour plot (right). label{quivermatplotlib}


=== A two-dimensional vector field ===

Another vector field to be used in examples is defined by

!bt
\begin{equation}
\bm{v}(x,y) = \left( x^2 + 2y - \frac{1}{2} xy\right)\bm{i}   - 3y\bm{j}.
label{2dvectorfieldeq}
\end{equation}
!et
We shall plot this field on a grid where the coordinates run over $[-5,5]$.
The chosen resolution gives a distance $0.5$ between the grid points where
the vector arrows are drawn. The grid and the evaluation of the vector field
on the grid are computed by

@@@CODE plot3d_matplotlib.py fromto: # Grid two-dimensional vector field@# endtwodimfield
The two-dimensional vector field (ref{2dvectorfieldeq}) is illustrated
in the left part of Figure ref{quivermatplotlib}.



=== A three-dimensional vector field ===

As an example of a three-dimensional vector field we consider a gravitational field.
Newtons law of gravitation says that the gravitational force is proportional to

!bt
\begin{equation}
\bm{v}(x, y, z) = -\bm{r}/|\bm{r}|^3 = -\frac{1}{\sqrt{x^2+y^2+z^2}^3}( x\bm{i} + y\bm{j} + z\bm{k}), label{3dvectorfieldeq}
\end{equation}
!et
where $\bm{r}=(x,y,z)$ is the position vector. In this case, we need a
three-dimensional grid for plotting, here defined by coordinates
$[0.5, 2]$ along each axis with only 7 intervals to avoid too dense arrows:

@@@CODE plot3d_matplotlib.py fromto: # Grid three-dimensional vector field@# endthreedimfield
The cube of the distance (`r3`) has here been computed once, since all three components are divided by this quantity.
Figure ref{quivermatplotlibgr} displays this vector field,
and the necessary code is explained in Section ref{matplotlibquiverplots}.

FIGURE:[fig/quiver_matplotlib_gr, height=400 width=600 frac=0.8] A three-dimensional gravitational force field. label{quivermatplotlibgr}

[hpl: Together with a 3D vector example with Mayavi,
this is the only example on 3D field. Looks strange to talk about
3D vector fields without 3D scalar fields, but 3D scalar fields is
a comprehensive topic. Should we drop 3D? Or should we add some basic
3D Mayavi for scalar fields? In general, I find ``plotting in three
dimensions'' somewhat confusing since contours are usually in 2D, while
lifted surfaces are 3D, but the common feature is that a 2D field is
visualized. I like better to talk about 2D fields and then different
techniques in 2D and 3D for visualizing such fields.]


======= Matplotlib =======

We import any visualization package under the name `plt`, so
for Matplotlib, the import is done by

!bc pycod
import matplotlib.pyplot as plt
!ec
Note that a `plt.show()` command is necessary to force Matplotlib to show a plot on the screen. When creating two-dimensional plots of
scalar and vector fields, we shall make use
of a Matplotlib ``axes'' object, called `ax` and made by

!bc pycod
fig = plt.figure()
ax = fig.gca()
!ec
For three-dimensional visualization, we need the following alternative
lines:

!bc pycod
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure()
ax = fig.gca(projection='3d')
!ec




===== Simple surface plots =====
label{matplotlibsurfaceplots}

A surface plot of a two-dimensional scalar field $h(x,y)$ is a visualization
of the surface $z=h(x,y)$ in three-dimensional space.
The Matplotlib command to produce such a surface is `ax.plot_surface`:

!bc pycod
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_surface(xv, yv, hv)
!ec
The result appears in the left part of
Figure ref{plotmatplotlib}.

A surface with colors reflecting the height of the surface (i.e., the value
of the scalar field) needs specification of a *color map*, i.e.,
what type of colors to be used. Below we apply the common `coolwarm`
scheme which goes from blue (``cool'' color for minimum values) to
red (``varm'' color for maximum values):

!bc pycod
fig = plt.figure()
ax = fig.gca(projection='3d')
from matplotlib import cm
ax.plot_surface(xv, yv, hv, cmap=cm.coolwarm)
!ec
There are lots of colormaps to choose from.

We can add the parameterized curve $\bm{r}(t)$, defined by (ref{req}),
to the latter plot:

!bc pycod
ax.plot(curve_x, curve_y, curve_z) # Plot of parametrised curve
!ec
By default, Matplotlib adds plots to each other without any need
for `plt.hold('on')`.
The resulting color plot with the curve appears in the right part
of Figure ref{plotmatplotlib}.



===== Contour plots =====

Contour lines are lines defined by the implicit equation $h(x,y)=C$, where
$C$ is some constant representing the contour level.
Different contour lines arise by the contour level.
Very often, we let $C$ run over some equally spaced values, and the
plotting program computes relevant $C$ values.
The following code exemplifies how one can create different types of contour plots.

@@@CODE plot3d_matplotlib.py fromto: # Default two-dimensional contour plot@#end contourplots

The first two plots (default two-dimensional and three-dimensional contour plots) are shown in Figure ref{simplecontourmatplotlib}. The next 4 plots are shown in Figure ref{advancedcontourmatplotlib}.

[hpl: Don't we need to create new figures above to get separate plots as we refer to in the figures?]

FIGURE:[fig/simple_contour_matplotlib, height=400 width=600 frac=0.8]  Default two-dimensional (left) and three-dimensional (right) contour plots with Matplotlib. label{simplecontourmatplotlib}

FIGURE:[fig/advanced_contour_matplotlib, height=400 width=600 frac=0.8] Some other contour plots with Matplotlib: 10 contour lines (upper left), 10 black contour lines (upper right), specified contour levels (lower left), and labeled levels (lower right). label{advancedcontourmatplotlib}





===== Vector field plots =====
label{matplotlibquiverplots}

The following code plots the two-dimensional vector field (ref{2dvectorfieldeq}), the gradient field (ref{gradienteq}) together with contours, and finally the three-dimensional vector field (ref{3dvectorfieldeq}).

!bc pycod
fig = plt.figure()
ax = fig.gca()

# angles and scale_units express that the vector field should
# have arrow lengths equal to the real vector lengths.
# color indicates the color to be used for the vectors (here blue).
ax.quiver(xv, yv, u, v, angles='xy', scale_units='xy',
          color='b')

fig = plt.figure()
ax = fig.gca()
ax.quiver(x2v, y2v, dhdx, dhdy, color='r', angles='xy')
ax.contour(xv, yv, hv)

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.quiver(xv, yv, zv, u, v, w, color='r', length=0.2)
!ec
[hpl: What does it mean when `angles` is present but `scale_units` is left out?]
The first two plots are shown in Figure ref{quivermatplotlib}, and the third in Figure ref{quivermatplotlibgr}.

A challenge in plots of vector fields is to get the right arrow lengths such
that the arrows are well visible, but they do not collide and make a
cluttered visual impression. Since the arrows are drawn at each point in
the 2D grid, one way of controlling the number of arrows is to control
the resolution of the grid.
The `ax.quiver` function also features a `scale` parameter, and
increasing this parameter results in shorter vectors.
[hpl: `scale` is not used in the examples!]
Matplotlib will attempt to scale arrows automatically if the `scale` parameter is not set.



======= SciTools =======

SciTools can work with different plotting engines (backends).
Usually, we employ Matplotlib
in the forthcoming figures, but sometimes Gunplot is required to realize
a certain feature.

[hpl: Seems that Gnuplot is used.]

[hpl: Maybe the VTK backend for SciTools would yield more functionality?]

Below we will use the prefix `plt` for the package `scitools.easyviz`:

!bc pycod
import scitools.easyviz as plt
!ec


===== Simple surface plots =====

To make the grid, one can either use `meshgrid` as shown above or
`plt.ndgrid` which requires fewer peculiar parameters:

!bc pycod
xv, yv = plt.ndgrid(x, y)       # Grid for contour plot
x2v, y2v = plt.ndgrid(x2, y2)   # Coarser grid for quiver plot
!ec

Simple surface plots of $h(x,y)$ in (ref{heq}) (coloured together with the parametric curve $\bm{r}(t)$ in (ref{req})) can now be produced as follows.

[hpl: This is confusing: What does Gnuplot backend as comment mean? The thing is that `mesh` and `surf` are not supported by the Matplotlib interface. Must explain what `mesh` and `surf` etc.]

!bc pycod
plt.mesh(xv, yv, hv) # Gnuplot backend

plt.surf(xv, yv, hv) # Gnuplot backend
plt.hold(â€˜onâ€™)
plt.plot3(curve_x, curve_y, curve_z, 'r-') # Gnuplot backend
!ec
The results are shown in Figure ref{plotscitools}.

FIGURE:[fig/plot_scitools, height=400 width=600 frac=0.8] Two SciTools surface plots. Plot without colours (left), and a plot with colours (right) shown together with a parametric curve which is a trajectory to the top of the mountain. label{plotscitools}

[hpl: Figure ref{plotscitools} has confusing caption: There are colors in both figures.]

===== Contour plots =====

[hpl: Try to avoid referring to the Matplotlib examples if possible. Just say what you want to plot and show code. Update comments in the code so that they are the same (if possible) for all plotting tools.]

The following code examplifies how one can create the same types of contour plots as above with SciTools. As is seen, there are only minor differences in how the parameters (colour, levels, labeling) to the plot are set.

!bc pycod
# Default two-dimensional contour plot: with X contour lines
plt.contour(xv, yv, hv)

# Default three-dimensional contour plot (Gnuplot backend)
plt.contour3(xv, yv, hv)

# 10 contour lines. The contour levels will be automatically chosen.
plt.contour(xv, yv, hv, 10)

# 10 contour lines. Black color for contour lines
plt.contour(xv, yv, hv, 10, 'k')

# Specify the contour levels
levels = [500., 1000., 1500., 2000.]
plt.contour(xv, yv, hv, levels)

# Add labels with the contour line values to the lines
plt.contour(xv, yv, hv, levels, clabels='on')
!ec
The first two plots (default two-dimensional and three-dimensional contour plots) are shown in Figure ref{simplecontourscitools}. The next 4 plots are shown in Figure ref{advancedcontourscitools}.

FIGURE:[fig/simple_contour_scitools, height=400 width=600 frac=0.8]  Default two-dimensional (left) and three-dimensional (right) contour plots with SciTools. label{simplecontourscitools}

FIGURE:[fig/advanced_contour_scitools, height=400 width=600 frac=0.8] Some other contour plots with SciTools: With 10 contour lines (upper left), with 10 contour lines in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourscitools}



===== Vector field plots =====

There is limited support for plotting three-dimensional vector fields in SciTools (the function is called `contour3`), so the following code only concerns the gradient field (ref{gradienteq}) and the two-dimensional vector field (ref{2dvectorfieldeq}).

!bc pycod
# The two last parameters represent scaling (0 means no scaling)
# and color (â€˜bâ€™ means blue).
plt.quiver(xv, yv, u, v, 200, 'b')

plot.figure()
plt.quiver(x2v, y2v, dhdx, dhdy, 0, 'r')
plt.hold('on')
plt.contour(x, y, h, daspectmode='equal')
!ec
The results are shown in Figure ref{quiverscitools}.

FIGURE:[fig/quiver_scitools, height=400 width=600 frac=0.8] Vector field plots with SciTools. The two-dimensional vector field (left), contour plot together with gradient field (right). label{quiverscitools}


======= Mayavi =======

Mayavi[^mayaviurl] is an advanced, free, easy to use, scientific data visualizer, with an emphasis on 3D graphics.
The package is written in Python, and uses the Visualization Toolkit (VTK) in C++ for rendering graphics. Since VTK can be configured with different backends, so can Mayavi.
Mayavi is cross platform and runs on most platforms, including Mac OSX, Windows, Linux.

[^mayaviurl]: The page URL: "http://docs.enthought.com/mayavi/mayavi/" collects pointers to all relevant documentation of Mayavi.

The `mayavi.mlab` module provides a simple interface to plotting of 2D
scalar and vector fields with commands that mimic those of Matlab.
Let us import this module under our usual name `plt` for a plotting package:

!bc pycod
import mayavi.mlab as plt
!ec

The official documentation of the `mlab` module is provided in two places, one for
the "basic functionality": "http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html" and one for "further functionality":
"http://docs.enthought.com/mayavi/mayavi/auto/mlab_other_functions.html".


===== The basics =====

[hpl: ``The basics'' of what?]

[hpl: After some thinking, I suggest taking this section out unless we
have some good example on plotting in at least two figures simultaneously so
you need to switch between them. Otherwise the figure handling does not
make much sense to a reader.]

We first need to cover some of the basic "figure handling":
"http://docs.enthought.com/mayavi/mayavi/auto/mlab_figure.html"
functions in the `mayavi.mlab` module.
The plotting commands you do in `mlab` will go into the same figure, until you change to a new figure.
The following code explains the use of some of the basic figure handling functions together with a simple surface plot.

[hpl: What is the figure handling? You just create one figure...]

[hpl: We have not used `clf` previously with Matplotlib. Is it really necessary? Can't we just create a new figure?]

[hpl: Be careful with comments in cod: Don't comment obvious things and emphasize commenting on ideas.]

!bc pycod
plt.clf() # Clear current figure, and return a handle to it.

# Create a figure with white background and black foreground.
# Specify colors with RGB values: (0,0,0) for black,
# (1,1,1) for white.
plt.figure(fgcolor=(.0,.0,.0), bgcolor=(1.0,1.0,1.0))

plt.mesh(xv, yv, hv, extent=(0, 1, 0, 1, 0, 1))
plt.title('My first plot')

# Set axes with given labels, 5 ticks on each axis, and black color
plt.axes(xlabel='x', ylabel='y', zlabel='z', nb_labels=5,
         color=(0.,0.,0.))

plt.savefig('plot.png')
plt.close()
!ec

[hpl: Explain the `extent` parameter. Ah, it comes later, I see. But it is confusing above.]

There is no function `plt.show()` in Mayavi. Instead the current figure is made visible by default.
The functions `clf()`, `close()`, `figure()`, `savefig()` all can take an optional parameter which identifies the figure in question (this parameter was not used above).
[hpl: Isn't this confusing information? We have used `figure(2)` before, but never `clf` and `close`. Do we really need them? They are typical Matlab functions, but not used regularly in Matplotlib earlier. Also, `savefig` already takes a parameter, and I don't think it is very useful to save a previous figure with its number; better to switch to a given figure and then do things with that figure. Below, `plt.gcf` and the other commands are confusing when there is just one figure. You need two at least to defend these commands, but that is a good idea - one often switches between plotting in two figures in real cases.]
Also, a figure can be identified or created in terms of a name, an index, or the figure object itself. [hpl: Isn't it easier to adopt just one rule, the one from Matlab with a figure number?]
The following code shows how one can jump between figures, to create different plots.

!bc pycod
fig = plt.gcf()        # Return the current figure object

# Set figure with index 1 to be the current one.
# It is created if it does not exist.
plt.figure(1)

# Set figure with name 'New plot' to be the current one.
plt.figure('New plot')

# Set the previously retrieved figure again to be the current one,
# and set the foreground and background colour.
plt.figure(fig, fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
!ec
If there exists no figure with the given name or index, `plt.figure()` will create a new one.
The function `plt.gcf()` returns the current figure object. You will need to call this in order to change the properties of the current figure,
such as the foreground or background colour above. Note that the foreground colour is used for text and labels included in the plot.

===== Simple surface plots =====

Above we called the function `mesh` to make a simple surface plot of the $h(x,y)$ in (ref{heq}). This works similarly to Matplotlib and SciTools, but note the extra parameter `extent=(0, 1, 0, 1, 0, 1)`.
Mayavi does no auto-scaling of the axes per default (contrary to SciTools and Matplotlib),
so if the magnitudes in the vertical and horizontal directions are very different (as they are for $h(x,y)$), the plots may be very concentrated in one direction.
`extent` ensures that the axes are auto-scaled to fit the contents of the surface.
We will return to what the six values listed in `extent` mean when we have
a more illustrating example.


To reproduce [hpl: Reproduce from what?] the coloured surface plot together with the parametric curve $\bm{r}(t)$ in (ref{req}), we can write

!bc pycod
plt.surf(xv, yv, hv, extent=(0, 1, 0, 1, 0, 1))
plt.plot3d(curve_x, curve_y, curve_z, tube_radius=0.2, \
           extent=(0, 1, 0, 1, 0, 1))
# tube_radius controls the width of the parametrized curve.
# Increased here in order to make the curve more visible
# when shown together with `surf`.
!ec
`surf` is more general than `mesh` according to the documentation, but for this plot we really see no differences. [hpl: This sentence sounds like the authors don't understand what they are trying to explain...]
Figure ref{plotmayavi} shows the resulting plots.
Rather unexpectedly we see that $\bm{r}(t)$ does not lie on the surface anymore.
The reason is that the ranges of the $x$-, $y$-, and $z$-values differ for the the curve and the surface, so that autoscaling will use different scales when placing them on the scene.
We therefore have to be a bit cautious when applying the autoscaling in Mayavi, and in the following contour plots we will avoid this autoscaling problem by scaling everything
first so that the coordinates are of comparable magnitude, so that there is no need for autoscaling in the first case.
One can also use other properties to scale the cases. [hpl: What are other properties? Or has next sentence something to do with it?] Some of the plotting commands below accept a `warp_scale` parameter, which tells us how the the vertical scaling should be performed.

FIGURE:[fig/plot_mayavi] Two Mayavi surface plots. Using `mesh` (left), and using `surf` (right) together with a parametric curve which is a trajectory to the top of the mountain. label{plotmayavi}



===== Subplots =====

The two plots in Figure ref{plotmayavi} were created as separate figures. One can also create them as subplots within one figure, so that one figure is generated with several subplots.
Consider the following code.

!bc pycod
plt.outline(plt.mesh(xv, yv, hv, extent=(0, 0.25, 0, 0.25, 0, 0.25),\
            color=(.5, .5, .5)))
plt.outline(plt.mesh(xv, yv, hv, \
            extent=(0.375, 0.625, 0, 0.25, 0, 0.25),\
            colormap='Accent'))
plt.outline(plt.mesh(xv, yv, hv, extent=(0.75, 1, 0, 0.25, 0, 0.25),\
            colormap='prism'))
!ec
The result is shown in the left plot in Figure ref{subplot}.


FIGURE:[fig/subplot] A plot with three subplots created with Mayavi, consisting of the same surface drawn with different color maps. label{subplot}

From this it should be clear that the six values listed in `extent` represent fractions of the cube `(0,1,0,1,0,1)`, where the corresponding plots are placed.
The extents for the three plots are defined so that they do not overlap.
Three separate `mesh` commands are run, each producing a new plot in the current figure.
The handles to the three plots are stored in the variables `surf1`, `surf2`, and `surf3`, [hpl: Where are these variables??] and
the function `outline` finally draws the corresponding box for the plot in question.

Note that the surfaces in Figure ref{subplot} are drawn with different colors. This is due to the `colormap` and `color` attributes in the call to `mesh`, which adjusts the colors when the surface is drawn.
The `color` attribute, which we see also can be used as a parameter to `outline`,
adjusts the surface so that it is coloured with small variations from the provided base-color.
One can choose from a wide range of different color maps.
[hpl: Try to rewrite this paragraph to get the message clearer and more fluent.]

===== Contour plots =====

The following code examplifies how one can create the same types of contour plots as above with Matplotlob. We see again some minor differences [hpl: in what? Results? Commands?], such as how colors here are specified by value. [hpl: You mean RGB tuple, not color string.]

!bc pycod
plt.contour_surf(xv, yv, hv)        # default: with X contour lines.

# 10 contour lines. The contour levels will be automatically chosen.
plt.contour_surf(xv, yv, hv, contours=10)

# 10 contour lines. Black color (i.e. (0., 0., 0.)) for contour lines.
plt.contour_surf(xv, yv, hv, contours=10, color=(0., 0., 0.))

# Specify the contour levels
levels = [500., 1000., 1500., 2000.]
plt.contour_surf(xv, yv, hv, contours=levels)
!ec
There seems to be no function in Mayavi which labels the contours, as we did with Matplotlib and ScitTools.
The plots are shown in Figure ref{advancedcontourmayavi}. Contour plots in Mayavi are shown in 3D, contrary to Matplotlib and SciTools [hpl: But you can rotate and look at them from above?]. Their visual appearance may be enhanced by also including the surface plot itself. We have here done this for two of the contour plots.
For comparison, we have not included the surface itself for the two last contour plots. There is a clear difference in visual impression between the two, and we see that the colour of the contours can conflict with the colour of the surface. [hpl: What do you mean by conflict? Seems to be the same colors, but plotting default contour colors on top of a surface will make the contours lines invisible?]

FIGURE:[fig/advanced_contour_mayavi, height=400 width=600 frac=0.8] Some contour plots with Mayavi: Default contour plot (upper left), with 10 contour lines (upper right), with 10 contour lines in black (lower left), and with specified levels (lower right). label{advancedcontourmayavi}


[hpl: MEK1100 emphasizes the need for showing contours and gradient arrows
in the same plot. Can we do that with Mayavi? Karsten will claim it is
fundamental...]


===== Plotting vector fields in 3D =====

Mayavis functionality for plotting vector fields is primarily intended for 3D also, so we will only plot the three dimensional field (ref{3dvectorfieldeq}).
This can be vizualized as follows.

[hpl: Here you explain arguments in more detail compared to Matplotlib,
although the arguments are the same. Coherent code and explanations are
important.]

!bc pycod
# Set foreground/background colour
plt.figure(fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
plt.quiver3d(xv, yv, zv, u, v, w, \
            mode='arrow', colormap='jet', scale_factor=.5)
# First three parameters are the points where vectors are drawn
# Next three parameters are the actual components of the vectors
# mode: ensures that the vectors are drawn as arrow.
# colormap: controls how the vectors are colored.
# scale_factor: manually scale vector lengths,
# so that vectors do not collide.
plt.axes(xlabel='x', ylabel='y', zlabel='z', \
        nb_labels=5, color=(0., 0., 0.))

!ec
The resulting plot is shown in Figure ref{quivermayavi}. This shows some of the challenges in plotting three-dimensional vector fields.
[hpl: I don't think we should show this inferior figure unless we have some remedy to make it clearer... Visualization of 3D vector fields is challenging.]
It may be challenging to create instructive plots, since vectors are drawn over an area in 3D rather than 2D.

FIGURE:[fig/quiver_mayavi, height=400 width=600 frac=0.8] The three-dimensional vector field plotted with Mayavi. label{quivermayavi}

===== Animations =====

[hpl: Emphasize saving figures to file for making videos.]

We have previously seen how to produce animations with Matplotlib and SciTools.
With the function `animate` in `mlab` we can also create animations.



This code will rotate the camera continuously. f is the current graphics.

!bc pycod
import mayavi as plt
@mlab.animate
def anim():
    f = plt.gcf()
    while 1:
        f.scene.camera.azimuth(10)
        f.scene.render()
        plt.yield

a = anim()
!ec