======= Examples on plotting of scalar and vector fields =======
label{plot:surf}

Visualization of scalar and vector fields in Python is commonly done
using Matplotlib or Mayavi. Both packages support basic visualization of
2D scalar and vector fields, but Mayavi offers more advanced techniques
for three-dimensional visualization, especially of 3D scalar and vector
fields.

(One can also use SciTools for visualizing 2D scalar and vector
fields, using either Matplotlib, Gnuplot, or VTK as plotting engines, but
this topic is omitted from the present book.
However, for fast visualization of 2D
scalar fields, Gnuplot is a viable tool, and the SciTools interface
offers a Matlab-style set of commands to operate Gnuplot.)

[hpl: These commands just hang in the air here without context.]
The commands `figure()` and `savefig()` are common for the plotting packages we consider.
In calls on the form `figure(num)` the parameter identifies the plot we work with,
and in calls on the form `savefig(filename)` the parameter identifies a file.

To exemplify visualization of scalar and vector fields with Matplotlib
and Mayavi, we use a common set of examples. A scalar function
of $x$ and $y$ is visualized in different ways, either as a flat
plot containing contour lines of the field, or as a three-dimensional
plot where the scalar field is lifted as a surface (according to the
function values). In the latter case we also add a three-dimensional
parameteric curve to the plot.

To illustrate plotting of
vector fields, we simply plot the gradient of the scalar field, but will
also illustrate two- and a three-dimensional vector fields
unrelated to a surface.

Our convention for variable names goes as follows:

* `x`, `y`, `z` for one-dimensional coordinates along each axis direction.
* `xv`, `yv`, `zv` are corresponding
  vectorized coordinates in a 2D or 3D grid.
* `u`, `v`, `w` are the compnents of a vector field
  at points corresponding to `xv`, `yv`, `zv`.

Sections contains more mathematical details on the various
scalar and vector fields we aim to plot.
#Most figures in this context
#we generated by Matplotlib.  Succeeding sections explain the
#corresponding code and how the same plots can be made with Mayavi.


===== Installation =====
label{plot:surf:install}

[hpl: Installation can be simplified now - we just need Mayavi.
Matplotlib is already available ``in the book''.]

For Ubuntu,
Section ref{sec:accesspy:vmware} describes installation of all the software
needed for plotting with the mentioned packages.
For Python programming on Mac OSX and Windows, we recommend using Anaconda. To obtain an environment for this, download the file `inf11003dplot.txt` from the bookâ€™s webpage,
and then create a conda environment named `inf11003dplot` with contents described in this file. This can be done by writing

!bc sys
conda create --name inf11003dplot --file inf11003dplot.txt
!ec
Then one has to activate the environment. The syntax for this depends on the platform:

!bc sys
source activate inf11003dplot # Mac OSX platforms
activate inf11003dplot        # Windows platforms
!ec


===== Surface plots =====
label{plot:surf:mesh_surf}

We consider the surface defined by

!bt
\begin{equation}
h(x,y) = \frac{h_0}{1+ \frac{x^2+y^2}{R^2}},
label{plot:surf:heq}
\end{equation}
!et
$h(x,y)$ may model the height of an isolated circular mountain,
$h$ being the height above sea level,
while $x$ and $y$ are Cartesian coordinates,
$h_0$ the height of the mountain, and $R$ the radius of the mountain.
Since mountains are actually quite flat (or more precisely,
their heights are small compared to the horizontal extent), we use
meter as length unit for vertical distances ($z$ direction) and km as length
unit for horizontal distances ($x$ and $y$ coordinates).
Prior to all code below we have initialized $h_0$ and $R$ with
the following values:

@@@CODE plot3d_matplotlib.py fromto: h0 =@#endinitvalues

===== Grid for two-dimensional fields =====
label{plot:surf:grid}

Before we can plot $h(x,y)$, we need to create a rectangular grid in the $xy$ plane with all the points used for plotting. Regardless of which plotting package we will use later on, the grid can be created as follows:

@@@CODE plot3d_matplotlib.py fromto: # Grid for x, y@# endinitgrid
The grid is based on equally spaced coordinates `x` and `y` in the
interval $[-10,10]$ km.
Note the mysterious extra parameters to `meshgrid` here, which are needed in order for the coordinates to have the right order in mathematics.

A surface plot of a two-dimensional scalar field $h(x,y)$ is a visualization of the surface $z=h(x,y)$ in three-dimensional space.
[hpl: The next is no longer true when we treat Matplotlib first...]
Most plotting packages have functions called `mesh` and `surf`, which both can be used to create surface plots.
`mesh` only colors the lines connecting the grid points, producing what is also called a *wireframe plot*.
`surf` on the other hand also colors the faces of the surface.
In Figure ref{plotmatplotlib} we have shown two plots of the surface $h(x,y)$. Section ref{matplotlibsurfaceplots} presents the code which generates these plots.

FIGURE:[fig/plot_matplotlib] Two different plots of a mountain. The right plot also shows a trajectory to the top of the mountain. label{plotmatplotlib}

===== Parametrized curve =====
label{plot:surf:3Dcurve}

To illustrate the plotting of three-dimensional parameterized curves,
we consider a trajectory that represents a circular climb to the top
of the mountain:

!bt
\begin{equation}
\bm{r}(t) = \left( 10\left(1 - \frac{t}{2\pi}\right)\cos(t) \right) \bm{i} + \left( 10\left(1 - \frac{t}{2\pi}\right)\sin(t) \right) \bm{j} + \frac{h_0}{1 + \frac{100(1 - t/(2\pi))^2}{R^2}} \bm{k}. label{plot:surf:req}
\end{equation}
!et
Here $\bm{i}$, $\bm{j}$, and $\bm{k}$ denote the unit vectors in the $x$-, $y$-, and $z$-directions, respectively.
The coordinates of $\bm{r}(t)$ can be produced by

@@@CODE plot3d_matplotlib.py fromto: s = np.linspace@# endparamcurve
The parametric curve is shown together with the surface $h(x,y)$ in the right plot in Figure ref{plotmatplotlib}.


===== Contour lines =====
label{plot:surf:contours}

Contour lines are lines defined by the implicit equation $h(x,y)=C$, where
$C$ is some constant representing the contour level.
Normally, we let $C$ run over some equally spaced values, and very often, the
plotting program computes the $C$ values.
To distinguish contours, one often associates each contour level $C$ with its own color.

Figure ref{simplecontourmatplotlib} shows different ways contour lines
can improve the visualization for the surface $h(x,y)$.  The first and
last plot are visualizations utilizing two spatial dimensions.  The
first draws a small set of contour lines only, while the last one
displays the surface as an image, whose colors reflect the values of
the field, or equivalently, the height of the surface.  The third plot
actually combines three different types of contours, each type
corresponding to keeping a coordinate constant and projecting the
contours on a ``wall''.  The code used to generate these plots is
presented in Section ref{matplotlibcontourplots}.

FIGURE:[fig/simple_contour_matplotlib, frac=1]  Different types of contour plots of a 2D scalar field in two and three dimensions. label{simplecontourmatplotlib}

===== The gradient vector field and the normal vector field =====
label{plot:surf:gradient}

The *gradient vector field* $\nabla h$ of a surface $h(x,y)$ is defined by

!bt
\begin{equation}
\nabla h = \frac{\partial h}{\partial x}\bm{i} +  \frac{\partial h}{\partial y}\bm{j}.
label{plot:surf:gradient:eq}
\end{equation}
!et
One learns in vector calculus that the gradient points in the direction where $h$ increases most, and
that the gradients are orthogonal to the contour lines.
This is something we can easily illustrate by combining plots of the contours and the gradient vector field.


A challenge in plots of vector fields is to get the right arrow lengths so
that the arrows are well visible, but they do not collide and make a
cluttered visual impression. Since the arrows are drawn at each point in
a 2D grid, one way of controlling the number of arrows is to control
the resolution of the grid. So, let us use a grid with 20 instead of 40 intervals in the horizontal
directions:

@@@CODE plot3d_matplotlib.py fromto: # Define a coarser grid for the vector field@# endcoarsergrid
The gradient vector field of $h(x,y)$ can now be computed using the function `np.gradient`:

@@@CODE plot3d_matplotlib.py fromto: dhdx, dhdy@# endgradient
The gradient field (ref{plot:surf:gradient:eq}) appears in Figure ref{plot:surf:mpl:quiver:fig}.
Section ref{plot:surf:mpl:quiver} explains the code needed to make these
plots.

FIGURE:[fig/quiver_matplotlib, frac=1] Gradient field with contour plot (left) and just a 2D vector field (right). label{plot:surf:mpl:quiver:fig}

The *normal vector field* of $h(x,y)$ is defined by

!bt
\begin{equation}
\bm{n}(x, y) = -\frac{\partial h}{\partial x}\bm{i}  -\frac{\partial h}{\partial y}\bm{j} + \bm{k}.
label{noemalvectoreq}
\end{equation}
!et
We see that, up to a sign a change, the normal vector field is simply an embedding of the gradient vector field in 3D,
obtained by adding a constant third component.

[hpl: This next paragraph
is unclear. In calculus, as you have already said,
one learns that the gradient field is
normal to the surface, and that is the property of importance in mechanics
and physics applications. Here you switch sign and
add a third component without motivation. I also think the plots are
too cluttered to be able to sell this visualization technique.]

One learns in calculus that the normal vector field is perpendicular to the surface.
In Figure ref{quivercontoursurfmatplotlib} we have plotted the normal vector field, together with the contours and the surface.
Again the code can be found in Section ref{plot:surf:mayavi:quiver}.

FIGURE:[fig/quiver_contour_surf_matplotlib, height=400 width=600 frac=1] Normal vector field with contours (left), with surface (right). label{quivercontoursurfmatplotlib}


===== Another 2D vector field =====
label{plot:surf:another:vec}

[hpl: Why do we need this additional field?]

Another vector field to be used in examples is defined by

!bt
\begin{equation}
\bm{v}(x,y) = \left( x^2 + 2y - \frac{1}{2} xy\right)\bm{i}   - 3y\bm{j}.
label{plot:surf:another:vec:eq}
\end{equation}
!et
We shall plot this field on a grid where the coordinates run over $[-5,5]$.
The chosen resolution gives a distance $0.5$ between the grid points where
the vector arrows are drawn. The grid and the evaluation of the vector field
on the grid are computed by

@@@CODE plot3d_matplotlib.py fromto: # Grid two-dimensional vector field@# endtwodimfield
The 2D vector field (ref{plot:surf:another:vec:eq}) is illustrated in the right part of Figure ref{plot:surf:mpl:quiver:fig}.



===== A 3D scalar and vector field =====
label{plot:surf:3D:scalar:vector}

As an example of a 3D field we consider a gravitational field.
Newtons law of gravitation says that the gravitational force is
inversely proportional to the square of the distance to the center of
mass. Let us therefore consider the 3D scalar field

!bt
\begin{equation} label{plot:surf:3D:surfeq}
F(x, y, z) = \frac{1}{x^2 + y^2 + z^2}
\end{equation}
!et
The gradient field for this 3D scalar field is defined by

!bt
\begin{equation}
\nabla F = \frac{\partial F}{\partial x}\bm{i} +  \frac{\partial F}{\partial y}\bm{j} + \frac{\partial F}{\partial z}\bm{k}.
label{gradient3eq}
\end{equation}
!et
This is a 3D vector field.  Also in 3D the gradient field points in
the direction of maximum increase, and the contours are orthogonal to
the gradient field.  For 2D scalar fields contour lines were defined
by the implicit equation $h(x,y)=C$.  For 3D scalar fields the
implicit equation $F(x,y,z)=C$ instead gives rise to a surface, so it
is more appropriate to talk about contour surfaces.  For the field
(ref{plot:surf:3D:surfeq}) the contours are clearly spheres.  One easily
here computes the gradient field as $-2\bm{r}/|\bm{r}|^4$, where
$\bm{r} = x\bm{i} + y\bm{j} + z\bm{k})$ is the position vector.  The
gradient field thus points towards the origin, and the contours are
clearly spheres centered at the origin.  This immediately verifiies
the orthogoality between the contours and the gradient field in this
case.

The gravitational force is also directed towards the center of mass,
so that it also can be viewed as 3D vector field, with the same
direction as the gradient field.

!bt
\begin{equation}
\bm{v}(x, y, z) = -\frac{\bm{r}}{||\bm{r}||^3} = -\frac{1}{(x^2+y^2+z^2)^{3/2}}
(x\bm{i} + y\bm{j} + z\bm{k}), label{plot:surf:3D:veceq}
\end{equation}
!et
To visualize the fields (ref{plot:surf:3D:surfeq}) and
(ref{plot:surf:3D:veceq}) together, we draw enough contours, as we did in
the 2D case in the left part of Figure ref{plot:surf:mpl:quiver:fig}.  We
first need a three-dimensional grid.  Below we have chosen $[0.5, 2]$
along each axis with only 6 intervals to avoid too dense arrows:

@@@CODE plot3d_matplotlib.py fromto: # Grid three-dimensional vector field@# endthreedimfield
The distance (`rv`) is here computed, and all components divided by
this quantity.  In Figure ref{quivermayavi} we have shown the two
fields. This figure was produced with Mayavi, since Matplotlib lacks
functionaility for drawing contours of 3D scalar fields.  In Section
ref{plot:surf:mayavi:quiver} we will go through the code which
produced this plot.  Visualizing a 3D scalar field is clearly
challenging, and we shall only touch the subject.

FIGURE:[fig/quiver_mayavi, frac=1] The 3D scalar field (ref{plot:surf:3D:surfeq}) and the 3D vector field (ref{plot:surf:3D:veceq}). label{quivermayavi}


======= Matplotlib =======

We import any visualization package under the name `plt`, so
for Matplotlib the import is done by

!bc pycod
import matplotlib.pyplot as plt
!ec
When creating two-dimensional plots of
scalar and vector fields, we shall make use
of a Matplotlib `Axes` object, named `ax` and made by

!bc pycod
fig = plt.figure(1)   # Get current figure
ax = fig.gca()        # Get current axes
!ec
For three-dimensional visualization, we need the following alternative
lines:

!bc pycod
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(1)
ax = fig.gca(projection='3d')
!ec

===== Simple surface plots =====
label{matplotlibsurfaceplots}

The Matplotlib function for plotting a scalar field as an elevated
grid in three dimensions is `ax.plot_wireframe`, while
`ax.plot_surface` plots the surface continuously filled with
colors. (These two functions correspond to `mesh` and `surf` in other
plotting packages, such as Mayavi and Matlab.)  The following code
uses the functions to produce the plots shown in Figure
ref{plotmatplotlib}.

@@@CODE plot3d_matplotlib.py fromto:# Simple plot of mountain@# endsimpleplots
Recall that a final
`plt.show()` command is necessary to force Matplotlib to show a plot on the screen. Also note that the second plot in this figure is drawn using a finer grid of colors. This was controlled
using the `rstride` and  `cstride` parameters. The two plots illustrate the effect of giving these smaller values
[hpl: You need to explain what `rstride` means, i.e., the value 1 vs 2, otherwise the comment is just confusing in a learning context.]
[hpl: Later, when plotting vector fields, you emphasize where and how the grid
is made, should you not do the same here (this is the first time too!)?
Recall where all the v-variables
are computed...]

A surface with colors reflecting the height of the surface (i.e., the
value of the scalar field) needs specification of a *color map*, i.e.,
a mapping between function values and colors.
Above we applied the common `coolwarm`
scheme which goes from blue (``cool'' color for minimum values) to red
(``warm'' color for maximum values), as well as another scheme called
`Spectral`.  There are lots of colormaps to choose from, and you have
to experiment to find appropriate choices according to your taste and
to the problem at hand.

To the latter plot we also added the parameterized curve $\bm{r}(t)$,
defined by (ref{plot:surf:req}), using the command `plot`.  The
attribute `linewidth` was increased here in order to make the curve
more visible.  By default, Matplotlib adds plots to each other without
any need for `plt.hold('on')`, although such a command can indeed be
used.



===== Contour plots =====
label{matplotlibcontourplots}

The following code exemplifies different types of
contour plots.  The first two plots (default two-dimensional and
three-dimensional contour plots) are shown in Figure
ref{simplecontourmatplotlib}. The next four plots appear in Figure
ref{advancedcontourmatplotlib}.


@@@CODE plot3d_matplotlib.py fromto: # Default two-dimensional contour plot@#end contourplots

FIGURE:[fig/advanced_contour_matplotlib, height=400 width=600 frac=0.8] Some other contour plots with Matplotlib: 10 contour lines (upper left), 10 black contour lines (upper right), specified contour levels (lower left), and labeled levels (lower right). label{advancedcontourmatplotlib}


===== Vector field plots =====
label{plot:surf:mpl:quiver}

The code for plotting the gradient field (ref{plot:surf:gradient:eq}) together
with contours goes as explained below, once the grid has been defined as in
Section ref{plot:surf:gradient}.
The corresponding plots are shown in Figure ref{quivercontoursurfmatplotlib}.

@@@CODE plot3d_matplotlib.py fromto:# Draw contours and gradient field of h in two@# end draw contours and gradient field of h in two
With grid coordinates defined as in Section ref{plot:surf:another:vec},
the 2D vector field (ref{plot:surf:another:vec:eq}) can be plotted as follows.

@@@CODE plot3d_matplotlib.py fromto:# Draw 2D-field@# end draw 2D-field
The following code plots the normal vector field together with the contours of $h$ in 3D.

@@@CODE plot3d_matplotlib.py fromto:# Draw contours and normal vector field of h in three@# end draw contours and normal vector field of h in three
If we replace contours with the surface itself, we can use the following code.
[hpl: This code is empty!]

@@@CODE plot3d_matplotlib.py fromto:# Draw surface and gradient field of h@# end draw surface and gradient field of h

Finally the three-dimensional vector field (ref{plot:surf:3D:veceq})
can be plotted as follows, with the grid defined as in Section
ref{plot:surf:3D:scalar:vector}.

@@@CODE plot3d_matplotlib.py fromto:# Draw 3D-field@# end draw 3D-field
Note that we have manually set the lengths of the vectors here.
The first two plots are shown in Figure ref{plot:surf:mpl:quiver:fig}, and the third in Figure ref{plot:surf:mpl:quiver:fig:gr}.

FIGURE:[fig/quiver_matplotlib_gr, height=400 width=600 frac=0.8] The 3D vector field (ref{plot:surf:3D:veceq}). label{plot:surf:mpl:quiver:fig:gr}




# #ifdef SCITOOLS_2D3D
======= SciTools =======

SciTools can work with different plotting engines (backends).
Usually, we employ Matplotlib
in the forthcoming figures, but sometimes Gunplot is required to realize
a certain feature. Below we will use the prefix `plt` for the package `scitools.easyviz`:

!bc pycod
import scitools.easyviz as plt
!ec


===== Simple surface plots =====

To make the grid, one can either use `meshgrid` as shown above or
`plt.ndgrid` which requires fewer peculiar parameters:

!bc pycod
xv, yv = plt.ndgrid(x, y)       # Grid for contour plot
x2v, y2v = plt.ndgrid(x2, y2)   # Coarser grid for quiver plot
!ec

Simple surface plots of $h(x,y)$ in (ref{plot:surf:heq}) (coloured together with the parametric curve $\bm{r}(t)$ in (ref{plot:surf:req})) can be produced with `mesh` and `surf` as follows.

[hpl: This is confusing: What does Gnuplot backend as comment mean? The thing is that `mesh` and `surf` are not supported by the Matplotlib interface. Must explain what `mesh` and `surf` etc.]

[or: The matplotlib equivalents of mesh and surf are plotwireframe and plotsurface. Scitools should translate calls to mesh and surf to these for the matplotlib backend. Still this does not seem to work well with, so I use Gnuplot. Should fix with Johannes.
Also, I have not had much luck with the VTK backend]

[or: I changed backend to gnuplot for contour plots, but it seems then that I cannot set the colour of the labels anymore, see the plot. I think Scitools is simply not tested enough for 3D here]

@@@CODE plot3d_scitools_gnuplot.py fromto:# Simple plot of mountain@# endsimpleplots

The results are shown in Figure ref{plotscitools}. A Gnuplot backend was used here.

FIGURE:[fig/plot_scitools, height=400 width=600 frac=0.8] Two SciTools surface plots: `mesh` (left) and `surf` (right). The curve $\bm{r}(t)$ is also shown in the right plot. label{plotscitools}



===== Contour plots =====

[hpl: Try to avoid referring to the Matplotlib examples if possible. Just say what you want to plot and show code. Update comments in the code so that they are the same (if possible) for all plotting tools.]

The following code exemplifies how one can create different contour plots with SciTools. As is seen, there are only minor differences in how the parameters (colour, levels, labeling) to the plot are set.

@@@CODE plot3d_scitools_gnuplot.py fromto: # Default two-dimensional contour plot@#end contourplots

The first two plots (default two-dimensional and three-dimensional contour plots) are shown in Figure ref{simplecontourscitools}. The next 4 plots are shown in Figure ref{advancedcontourscitools}.

FIGURE:[fig/simple_contour_scitools, height=400 width=600 frac=0.8]  Default two- and three-dimensional contour plots with SciTools. label{simplecontourscitools}

FIGURE:[fig/advanced_contour_scitools, height=400 width=600 frac=0.8] Some other contour plots with SciTools: With 10 contour lines (upper left), with 10 contour lines in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourscitools}



===== Vector field plots =====

There is limited support for plotting three-dimensional vector fields in SciTools (the function is called `contour3`), so the following code only concerns the gradient field (ref{plot:surf:gradient:eq}) and the two-dimensional vector field (ref{plot:surf:another:vec:eq}).
The code for plotting the gradient field together with contours goes as follows.

@@@CODE plot3d_scitools.py fromto:# Draw contours and gradient field of h@# end draw contours and gradient field of h
The two-dimensional vector field (ref{plot:surf:another:vec:eq}) can be plotted as follows.
[hpl: I don't see why we need a different field here. Why not just plot $\nabla h$ with the commands one wants to illustrate? You seem to want to illustrate
how to set units for the vectors, but that should be explicitly explained
in the text, and I think the example is clearer if we use the same field but
different units or scalings.]

@@@CODE plot3d_scitools.py fromto:# Draw 2D-field@# end draw 2D-field.
The results are shown in Figure ref{quiverscitools}.

FIGURE:[fig/quiver_scitools, height=400 width=600 frac=0.8] Vector field plots with SciTools. Gradient field with contour plot (left). 2D vector field (right). label{quiverscitools}

# #endif

======= Mayavi =======

Mayavi is an advanced, free, easy to use, scientific data visualizer, with an emphasis on three-dimensional visualization techniques.
The package is written in Python, and uses the Visualization Toolkit (VTK) in C++ for rendering graphics. Since VTK can be configured with different backends, so can Mayavi.
Mayavi is cross platform and runs on most platforms, including Mac OSX, Windows, Linux.

The web page URL: "http://docs.enthought.com/mayavi/mayavi/" collects pointers to all relevant documentation of Mayavi.
We shall primarily deal with the
`mayavi.mlab` module, which provides a simple interface to plotting of 2D
scalar and vector fields with commands that mimic those of Matlab.
Let us import this module under our usual name `plt` for a plotting package:

!bc pycod
import mayavi.mlab as plt
!ec

The official documentation of the `mlab` module is provided in two places, one for
the "basic functionality": "http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html" and one for "further functionality":
"http://docs.enthought.com/mayavi/mayavi/auto/mlab_other_functions.html".
Basic "figure handling":"http://docs.enthought.com/mayavi/mayavi/auto/mlab_figure.html" is very similar as the one we know from Matplotlib.
Just as for Matplotlib, plotting commands you do in `mlab` will go into the same figure, until you manually change to a new figure.


===== Simple surface plots =====

Mayavi has functions `mesh` and `surf` for making simple surface plots,
corresponding to the `ax.plot_wireframe` and `ax.plot_surface` in Matplotlib.
Contrary to most other plotting packages, Mayavi's `mesh`
function does color the face of the surface.
The following code uses these two functions
to plot the surface $h(x,y)$ in (ref{plot:surf:heq}), as well as the parametric curve $\bm{r}(t)$ in (ref{plot:surf:req}).

@@@CODE plot3d_mayavi.py fromto:# Simple plot of mountain@# endsimpleplots

The calls to `plt.figure()` take three parameters: First the usual index for the plot, then two tuples of numbers , representing the RGB-values to be used for the foreground (`fgcolor`) and the background (`bgcolor`).
White and black are  (1,1,1) and (0,0,0), respectively. The foreground color is used for text and labels included in the plot.

The `color` attribute adjusts the surface so that it is colored with small variations from the provided base color.
[hpl: What is the base color?]
Note also the extra parameter `extent`.
Mayavi does no auto-scaling of the axes per default (contrary to Matplotlib),
so if the magnitudes in the vertical and horizontal directions are very different (as they are for $h(x,y)$), the plots may be very concentrated in one direction.
The `extent` parameter ensures that the axes are auto-scaled to fit the contents of the surface.
We will return to what the six values listed in `extent` mean when we have
a more illustrating example.

The command `plot3d` is used to plot the curve $\bm{r}(t)$.  The
attribute `tube_radius` is explicitly set in order to make the curve
more visible.

Figure ref{plotmayavi} shows the resulting plots.
Rather unexpectedly we see that $\bm{r}(t)$ does not lie on the surface anymore.
The reason is that the ranges of the $x$-, $y$-, and $z$-values differ for the curve and the surface,
so that autoscaling will use different scales when placing them on the scene.
We therefore have to be a bit cautious when applying the autoscaling in Mayavi,
and in the following contour plots we will avoid this autoscaling problem by scaling everything
first so that the coordinates already are of the same order of magnitude.

FIGURE:[fig/plot_mayavi] Two Mayavi surface plots: `mesh` (left) and `surf` (right). The curve $\bm{r}(t)$ is also shown in the right plot. label{plotmayavi}



===== Subplots =====

The two plots in Figure ref{plotmayavi} were created as separate figures. One can also create them as subplots within one figure:

@@@CODE plot3d_mayavi.py fromto:# Create one figure with three subplots@# endsubplot
The result is shown in Figure ref{subplot}.
From the code it is hopefully clear that the six values listed in `extent` represent fractions of the cube `(0,1,0,1,0,1)`, where the corresponding plots are placed.
The extents for the three plots are defined so that they do not overlap.
Three separate `mesh` commands are run, each producing a new plot in the current figure.
The commands use different values for the `colormap` attribute to color the surface in different ways.
The two latter plot handles are sent as input to the `plt.outline` command, which produces the frames we see in the figure.
We see that the last plot has a frame with a different color. This is due to the `color`-attribute, which was added in the last call to `plt.outline`.
[hpl: The last frame is not visible in the figure.]

FIGURE:[fig/subplot, frac=1] A plot with three subplots created with Mayavi. label{subplot}



===== Contour plots =====

The following code exemplifies how one can produce contour plots with
Mayavi.  The code is very similar to that of Matplotlib, but one
difference is that the attribute `contours` now can represent the
number of levels, as well as the levels themselves:

@@@CODE plot3d_mayavi.py fromto:# Default contour plot plotted together with surf@#end contourplots
There seems to be no function in Mayavi which labels the contours.
The plots are shown in Figure ref{advancedcontourmayavi}.

Contour plots in Mayavi are shown in 3D, but you can rotate and look at them from above if you want a two-dimensional contour plot.
Their visual appearance may be enhanced by also including the surface plot itself. We have here done this for two of the contour plots.
There is a clear difference in visual impression between the two. In the first one default surface- and contour coloring was used, resulting in less visible contours.
As we see, the contours are more visible when a black color is used.

FIGURE:[fig/advanced_contour_mayavi, height=400 width=600 frac=0.8] Some contour plots with Mayavi. label{advancedcontourmayavi}



===== Vector field plots =====
label{plot:surf:mayavi:quiver}

Mayavi's functionality for plotting vector fields is primarily intended for viewing in 3D, so we will not plot the two-dimensional field (ref{plot:surf:another:vec:eq}).
[hpl: So you cannot just view from above??? Recall that the two dimensional contour plot with normal vector field is much used in MEK1100.]
The following code plots the normal vector field together with the contours of $h$ in 3D.

@@@CODE plot3d_mayavi.py fromto:# Draw contours and normal vector field of h@# end draw contours and normal vector field of h
The color of the vectors were here set to red, and the attribute `scale_factor` adjusted so that vectors do not collide.
Still the plot look a bit cluttered. If we replace contours with the surface itself, we can use the following code.

@@@CODE plot3d_mayavi.py fromto:# Draw surface and normal vector field of h@# end draw surface and normal vector field of h
The corresponding plots are shown in Figure ref{quivercontoursurfmayavi}.

FIGURE:[fig/quiver_contour_surf_mayavi, height=400 width=600 frac=1] Normal vector field with contours (left), with surface (right). label{quivercontoursurfmayavi}

The contours of the 3D scalar field (ref{plot:surf:3D:surfeq}) and the
3D vector field (ref{plot:surf:3D:veceq}), as shown in Figure
ref{quivermayavi}, were produced as follows.

@@@CODE plot3d_mayavi_manual.py fromto:# Draw countours of 3D scalar field together with 3D vector field@# end draw countours of 3D scalar field together with 3D vector field
This example
demonstrates some of the challenges in plotting three-dimensional vector fields.
The vectors must not be too dense, and not too long.
It is inevitable that contours shadow for one another, so that we must use some degree of opacity.




===== Animations =====

[hpl: Emphasize saving figures to file for making videos.]

We have previously seen how to produce animations with Matplotlib and SciTools.
With the function `animate` in `mlab` we can also create animations.



This code will rotate the camera continuously. f is the current graphics.

!bc pycod
import mayavi as plt
@mlab.animate
def anim():
    f = plt.gcf()
    while 1:
        f.scene.camera.azimuth(10)
        f.scene.render()
        plt.yield

a = anim()
!ec