
======= Examples on plotting of scalar and vector fields =======
label{plot:surf}

% if MATLAB_TOO:
We shall demonstrate visualization of scalar and vector fields
using Matplotlib, Mayavi, and Matlab. The former two packages requires
a bit of Python programming.
% else:
Visualization of scalar and vector fields in Python is commonly done
using Matplotlib or Mayavi. Both packages support basic visualization of
2D scalar and vector fields, but Mayavi offers more advanced
three-dimensional visualization techniques,
especially for 3D scalar and vector fields.

One can also use SciTools for visualizing 2D scalar and vector
fields, using either Matplotlib, Gnuplot, or VTK as plotting engines, but
this topic is omitted from the present book.
However, for fast visualization of large 2D
scalar fields, Gnuplot is a viable tool, and the SciTools interface
offers a convenient Matlab-style set of commands to operate Gnuplot.
% endif

To exemplify visualization of scalar and vector fields with
% if MATLAB_TOO:
various tools,
% else:
Matplotlib and Mayavi,
% endif
we use a common set of examples. A scalar function of $x$
and $y$ is visualized either as a flat two-dimensional plot with
contour lines of the field, or as a three-dimensional surface where
the height of the surface corresponds to the function value of the
field. In the latter case we also add a three-dimensional
parameterized curve to the plot.

To illustrate plotting of vector fields, we simply plot the gradient of the scalar field, together with the scalar field.
Our convention for variable names goes as follows:

* `x`, `y` for one-dimensional coordinates along each axis direction.
* `xv`, `yv` for the corresponding
  vectorized coordinates in a 2D.
* `u`, `v` for the components of a vector field
  at points corresponding to `xv`, `yv`.

The following sections contain more mathematical details on the various
scalar and vector fields we aim to plot.
#Most figures in this context
#we generated by Matplotlib.  Succeeding sections explain the
#corresponding code and how the same plots can be made with Mayavi.

% if not MATLAB_TOO:
===== Installation =====
label{plot:surf:install}

Previously in the book we have explained how to obtain Matplotlib for various platforms.
To obtain Mayavi on Ubuntu platforms you can write

!bc sys
pip install mayavi --upgrade
!ec
For Mac OS X and Windows, we recommend using Anaconda.
To obtain Mayavi for Anaconda you can write

!bc sys
conda install mayavi
!ec

% endif


===== Surface plots =====
label{plot:surf:mesh_surf}

We consider the 2D scalar field defined by

!bt
\begin{equation}
h(x,y) = \frac{h_0}{1+ \frac{x^2+y^2}{R^2}}.
label{plot:surf:heq}
\end{equation}
!et
$h(x,y)$ may model the height of an isolated circular mountain,
$h$ being the height above sea level,
while $x$ and $y$ are Cartesian coordinates on the earth's surface,
$h_0$ the height of the mountain, and $R$ the radius of the mountain.
Since mountains are actually quite flat (or more precisely,
their heights are small compared to the horizontal extent), we use
meter as length unit for vertical distances ($z$ direction) and km as length
unit for horizontal distances ($x$ and $y$ coordinates).
Prior to all code below we have initialized $h_0$ and $R$ with
the following values: $h_0=2277$ m and $R=4$ km.


=== Grid for 2D scalar fields ===

Before we can plot $h(x,y)$, we need to create a rectangular grid in the $xy$ plane with all the points used for plotting.
% if MATLAB_TOO:
With Matplotlib and Mayavi we need the code

@@@CODE plot3d_matplotlib.py from-to: # Grid for x, y@# endinitgrid
while in Matlab we must write

@@@CODE plot3d_matlab.m from-to: % Grid for x, y@% endinitgrid
% else:
Regardless of which plotting package we will use later on, the grid can be made as follows:

@@@CODE plot3d_matplotlib.py from-to: # Grid for x, y@# endinitgrid
% endif
The grid is based on equally spaced coordinates `x` and `y` in the
interval $[-10,10]$ km.
Note the mysterious extra parameters to `meshgrid` here, which are needed in order for the coordinates to have the right order such that the arithmetics
in the expression for `hv` becomes correct.
The expression computes the
surface value at the $41\times 41$ grid points in one vectorized operation.

A surface plot of a 2D scalar field $h(x,y)$ is a visualization of the surface $z=h(x,y)$ in three-dimensional space.
Most plotting packages have functions which can be used to create surface plots of 2D scalar fields.
These can be either *wireframe plots*, where only lines connecting the grid points are drawn,
or plots where the faces of the surface are colored.
In Figure ref{plotmatplotlib} we have shown two such plots of the surface $h(x,y)$. Section ref{matplotlibsurfaceplots} presents the code which generates these plots.

FIGURE:[fig/plot_matplotlib] Two different plots of a mountain. The right plot also shows a trajectory to the top of the mountain. label{plotmatplotlib}

===== Parameterized curve =====
label{plot:surf:3Dcurve}

To illustrate the plotting of three-dimensional parameterized curves,
we consider a trajectory that represents a circular climb to the top
of the mountain:

!bt
\begin{equation}
\bm{r}(t) = \left( 10\left(1 - \frac{t}{2\pi}\right)\cos(t) \right) \bm{i} + \left( 10\left(1 - \frac{t}{2\pi}\right)\sin(t) \right) \bm{j} + \frac{h_0}{1 + \frac{100(1 - t/(2\pi))^2}{R^2}} \bm{k}. label{plot:surf:req}
\end{equation}
!et
Here $\bm{i}$, $\bm{j}$, and $\bm{k}$ denote the unit vectors in the $x$-, $y$-, and $z$-directions, respectively.
% if not MATLAB_TOO:
The coordinates of $\bm{r}(t)$ can be produced by

@@@CODE plot3d_matplotlib.py fromto: s = np.linspace@# endparamcurve
% else:
In Python the coordinates of $\bm{r}(t)$ can be produced by

@@@CODE plot3d_matplotlib.py fromto: s = np.linspace@# endparamcurve
while in Matlab we must write

@@@CODE plot3d_matlab.m fromto: s = linspace@% endparamcurve
% endif
The parameterized curve is shown together with the surface $h(x,y)$ in the right plot in Figure ref{plotmatplotlib}.





===== Contour lines =====
label{plot:surf:contours}

Contour lines are lines defined by the implicit equation $h(x,y)=C$, where
$C$ is some constant representing the contour level.
Normally, we let $C$ run over some equally spaced values, and very often, the
plotting program computes the $C$ values.
To distinguish contours, one often associates each contour level $C$ with its own color.

Figure ref{simplecontourmatplotlib} shows different ways contour lines
can be used to visualize the surface $h(x,y)$.  The first and
last plot are visualizations utilizing two spatial dimensions.  The
first draws a small set of contour lines only, while the last one
displays the surface as an image, whose colors reflect the values of
the field, or equivalently, the height of the surface.  The third plot
actually combines three different types of contours, each type
corresponding to keeping a coordinate constant and projecting the
contours on a ``wall''.  The code used to generate these plots is
presented in Section ref{matplotlibcontourplots}.

FIGURE:[fig/simple_contour_matplotlib, frac=1]  Different types of contour plots of a 2D scalar field in two and three dimensions. label{simplecontourmatplotlib}

===== The gradient vector field of $h$ =====
label{plot:surf:gradient}

The *gradient vector field* $\nabla h$ of a 2D scalar field $h(x,y)$ is defined by

!bt
\begin{equation}
\nabla h = \frac{\partial h}{\partial x}\bm{i} +  \frac{\partial h}{\partial y}\bm{j}.
label{plot:surf:gradient:eq}
\end{equation}
!et
One learns in vector calculus that the gradient points in the direction where $h$ increases most, and
that the gradients are orthogonal to the contour lines.
This is something we can easily illustrate by creating 2D plots of the contours and the gradient field.
A challenge in making such plots is to get the right arrow lengths so
that the arrows are well visible, but they do not collide and make a
cluttered visual impression. Since the arrows are drawn at each point in
a 2D grid, one way of controlling the number of arrows is to control
the resolution of the grid.

% if not MATLAB_TOO:
So, let us create a grid with 20 instead of 40 intervals in the horizontal
directions:
@@@CODE plot3d_matplotlib.py from-to: # Define a coarser grid for the vector field@# endcoarsergrid
The gradient vector field of $h(x,y)$ can now be computed using the function `np.gradient`:

@@@CODE plot3d_matplotlib.py fromto: dhdx, dhdy@# endgradient
% else:
So, let us create a grid with 20 instead of 40 intervals in the horizontal
directions:
In Python we write
@@@CODE plot3d_matplotlib.py from-to: # Define a coarser grid for the vector field@# endcoarsergrid
The gradient vector field of $h(x,y)$ can now be computed using the function `np.gradient`:

@@@CODE plot3d_matplotlib.py fromto: dhdx, dhdy@# endgradient
In Matlab we instead write

@@@CODE plot3d_matlab.m from-to: % Define a coarser grid for the vector field@% endcoarsergrid
The corresponding function for computing the gradient field in Matlab is called `gradient`:

@@@CODE plot3d_matlab.m from-to: % startgradient@% endgradient
% endif
The gradient field (ref{plot:surf:gradient:eq}) together with the contours appear in Figure ref{plot:surf:mpl:quiver:fig},
from which the orthogonality can be easily seen.
Section ref{plot:surf:mpl:quiver} explains the code needed to make this plot.

FIGURE:[fig/quiver_matplotlib_advanced, frac=0.8] Gradient field with contour plot. label{plot:surf:mpl:quiver:fig}





======= Matplotlib =======

We import any visualization package under the name `plt`, so
for Matplotlib the import is done by

!bc pycod
import matplotlib.pyplot as plt
!ec
When creating two-dimensional plots of
scalar and vector fields, we shall make use
of a Matplotlib `Axes` object, named `ax` and made by

!bc pycod
fig = plt.figure(1)   # Get current figure
ax = fig.gca()        # Get current axes
!ec
For three-dimensional visualization, we need the following alternative
lines:

!bc pycod
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(1)
ax = fig.gca(projection='3d')
!ec

===== Surface plots =====
label{matplotlibsurfaceplots}

The Matplotlib functions for producing surface plots of 2D scalar fields  are
`ax.plot_wireframe` and `ax.plot_surface`.
The first one produces a wireframe plot, and the second one colors the surface.
The following code uses the functions to produce the plots shown in Figure
ref{plotmatplotlib}, once the grid has been defined as in Section ref{plot:surf:mesh_surf},
and the coordinates of the parameterized curve have been computed as in Section ref{plot:surf:3Dcurve}.

@@@CODE plot3d_matplotlib.py from-to:# Simple plot of mountain@# endsimpleplots
Recall that a final
`plt.show()` command is necessary to force Matplotlib to show a plot on the screen.

Note that the second plot in this figure is drawn using a finer grid.
This is controlled with the `rstride` and `cstride` parameters, which
sets the number of grid lines in each direction.  Setting one of these
to 1 means that a grid line is drawn for every value in the grid in
the corresponding direction, and setting to 2 means that a grid line
will be drawn for every two values in the grid. You will normally need
to experiment with such parameters to get a visually attractive plot.

A surface with colors reflecting the height of the surface
needs specification of a *color map*, which is
a mapping between function values and colors.
Above we applied the common `coolwarm`
scheme which goes from blue (``cool'' color for minimum values) to red
(``warm'' color for maximum values).
There are lots of colormaps to choose from, and you have
to experiment to find appropriate choices according to your taste and
to the problem at hand.

To the latter plot we also added the parameterized curve $\bm{r}(t)$,
defined by (ref{plot:surf:req}), using the command `plot`.  The
attribute `linewidth` is increased here in order to make the curve thicker and
more visible.  By default, Matplotlib adds plots to each other without
any need for `plt.hold('on')`, although such a command can indeed be
used.



===== Contour plots =====
label{matplotlibcontourplots}

The following code exemplifies different types of
contour plots.  The first two plots (default two-dimensional and
three-dimensional contour plots) are shown in Figure
ref{simplecontourmatplotlib}. The next four plots appear in Figure
ref{advancedcontourmatplotlib}. Note that, when we asked Matplotlib to plot 10 contours,
the response was, surprisingly, 9 contour lines, where one of the contours was incomplete. 
This kind of behavior may also be found in other plotting packages: 
The package will do its best to plot the requested number of complete contour lines, 
but there is no guarantee that this number is achieved exactly.


@@@CODE plot3d_matplotlib.py fromto: # Default two-dimensional contour plot@#end contourplots

FIGURE:[fig/advanced_contour_matplotlib, height=400 width=600 frac=1] Some other contour plots with Matplotlib: 10 contour lines (upper left), 10 black contour lines (upper right), specified contour levels (lower left), and labeled levels (lower right). label{advancedcontourmatplotlib}


===== Vector field plots =====
label{plot:surf:mpl:quiver}

The code for plotting the gradient field (ref{plot:surf:gradient:eq}) together
with contours goes as explained below, once the grid has been defined as in
Section ref{plot:surf:gradient}.
The corresponding plot is shown in Figure ref{plot:surf:mpl:quiver:fig}.

@@@CODE plot3d_matplotlib.py from-to:# Draw contours and gradient field of h@# end draw contours and gradient field of h




# #ifdef SCITOOLS_2D3D
======= SciTools =======

SciTools can work with different plotting engines (backends).
Usually, we employ Matplotlib
in the forthcoming figures, but sometimes Gnuplot is required to realize
a certain feature. Below we will use the prefix `plt` for the package `scitools.easyviz`:

!bc pycod
import scitools.easyviz as plt
!ec


===== Surface plots =====

To make the grid, one can either use `meshgrid` as shown above or
`plt.ndgrid` which requires fewer peculiar parameters:

!bc pycod
xv, yv = plt.ndgrid(x, y)       # Grid for contour plot
x2v, y2v = plt.ndgrid(x2, y2)   # Coarser grid for quiver plot
!ec

Surface plots of $h(x,y)$ in (ref{plot:surf:heq}) (colored together with the parameterized curve $\bm{r}(t)$ in (ref{plot:surf:req})) can be produced with `mesh` and `surf` as follows.

[hpl: This is confusing: What does Gnuplot backend as comment mean? The thing is that `mesh` and `surf` are not supported by the Matplotlib interface. Must explain what `mesh` and `surf` etc.]

[or: The matplotlib equivalents of mesh and surf are plotwireframe and plotsurface. Scitools should translate calls to mesh and surf to these for the matplotlib backend. Still this does not seem to work well with, so I use Gnuplot. Should fix with Johannes.
Also, I have not had much luck with the VTK backend]

[or: I changed backend to gnuplot for contour plots, but it seems then that I cannot set the color of the labels anymore, see the plot. I think Scitools is simply not tested enough for 3D here]

@@@CODE plot3d_scitools_gnuplot.py from-to:# Simple plot of mountain@# endsimpleplots

The results are shown in Figure ref{plotscitools}. A Gnuplot backend is used here.

FIGURE:[fig/plot_scitools, height=400 width=600 frac=0.8] Two SciTools surface plots: `mesh` (left) and `surf` (right). The curve $\bm{r}(t)$ is also shown in the right plot. label{plotscitools}



===== Contour plots =====

[hpl: Try to avoid referring to the Matplotlib examples if possible. Just say what you want to plot and show code. Update comments in the code so that they are the same (if possible) for all plotting tools.]

The following code exemplifies how one can create different contour plots with SciTools. As is seen, there are only minor differences in how the parameters (color, levels, labeling) to the plot are set.

@@@CODE plot3d_scitools_gnuplot.py from-to: # Default two-dimensional contour plot@#end contourplots

The first two plots (default two-dimensional and three-dimensional contour plots) are shown in Figure ref{simplecontourscitools}. The next 4 plots are shown in Figure ref{advancedcontourscitools}.

FIGURE:[fig/simple_contour_scitools, height=400 width=600 frac=0.8]  Default two- and three-dimensional contour plots with SciTools. label{simplecontourscitools}

FIGURE:[fig/advanced_contour_scitools, height=400 width=600 frac=0.8] Some other contour plots with SciTools: With 10 contour lines (upper left), with 10 contour lines in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourscitools}



===== Vector field plots =====

There is limited support for plotting three-dimensional vector fields in SciTools (the function is called `contour3`),
so the following code only concerns the gradient field (ref{plot:surf:gradient:eq}).
The code for plotting the gradient field together with contours goes as follows.

@@@CODE plot3d_scitools.py from-to:# Draw contours and gradient field of h@# end draw contours and gradient field of h
The two-dimensional vector field (ref{plot:surf:another:vec:eq}) can be plotted as follows.
[hpl: I don't see why we need a different field here. Why not just plot $\nabla h$ with the commands one wants to illustrate? You seem to want to illustrate
how to set units for the vectors, but that should be explicitly explained
in the text, and I think the example is clearer if we use the same field but
different units or scalings.]

@@@CODE plot3d_scitools.py from-to:# Draw 2D-field@# end draw 2D-field.
The results are shown in Figure ref{quiverscitools}.

FIGURE:[fig/quiver_scitools, height=400 width=600 frac=0.8] Vector field plots with SciTools. Gradient field with contour plot (left). 2D vector field (right). label{quiverscitools}

# #endif

======= Mayavi =======

Mayavi is an advanced, free, easy to use, scientific data visualizer, with an emphasis on three-dimensional visualization techniques.
The package is written in Python, and uses the Visualization Toolkit (VTK) in C++ for rendering graphics. Since VTK can be configured with different backends, so can Mayavi.
Mayavi is cross platform and runs on most platforms, including Mac OS X, Windows, Linux.

The web page URL: "http://docs.enthought.com/mayavi/mayavi/" collects pointers to all relevant documentation of Mayavi.
We shall primarily deal with the
`mayavi.mlab` module, which provides a simple interface to plotting of 2D
scalar and vector fields with commands that mimic those of Matlab.
Let us import this module under our usual name `plt` for a plotting package:

!bc pycod
import mayavi.mlab as plt
!ec

The official documentation of the `mlab` module is provided in two
places, one for the "basic functionality":
"http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html"
and one for "further functionality":
"http://docs.enthought.com/mayavi/mayavi/auto/mlab_other_functions.html".
Basic "figure
handling":"http://docs.enthought.com/mayavi/mayavi/auto/mlab_figure.html"
is very similar to the one we know from Matplotlib.  Just as for
Matplotlib, all plotting commands you do in `mlab` will go into the
same figure, until you manually change to a new figure.


===== Surface plots =====

Mayavi has the functions `mesh` and `surf` for producing surface plots. 
These are similar, but `surf` assumes an orthogonal grid, and uses this assumption to make efficient data structures. 
`mesh` makes no such assumptions on the grid. 
We will only use orthogonal grids, so we will always use `surf`.  
The following code plots the surface $h(x,y)$ in (ref{plot:surf:heq}), as
well as the parameterized curve $\bm{r}(t)$ in (ref{plot:surf:req}).
The resulting graphics appears in Figure ref{plotmayavi}.

@@@CODE plot3d_mayavi.py from-to:# Simple plot of mountain@# endsimpleplots
`surf` can produce wireframe plots, 
as well as plots where the faces of the surface are colored. 
The parameter `representation` controls this, 
as exemplified in the first two plots.
The first plot was also decorated with axes and a title.

FIGURE:[fig/plot_mayavi] Surface plots produced with the `surf` function of Mayavi: The curve $\bm{r}(t)$ is also shown in the two last plots. label{plotmayavi}

The calls to `plt.figure()` take three parameters: First the usual index for the plot, then two tuples of numbers , 
representing the RGB-values to be used for the foreground (`fgcolor`) and the background (`bgcolor`).
White and black are  (1,1,1) and (0,0,0), respectively. The foreground color is used for text and labels included in the plot.
The `color` attribute in `plt.surf` adjusts the surface so that it is colored with small variations from the provided base color, here `(.5, .5, .5)`.

The command `plot3d` is used to plot the curve $\bm{r}(t)$.  We have here increased the
attribute `tube_radius` to make the curve thicker and more visible.

Mayavi does no auto-scaling of the axes by default (contrary to Matplotlib),
so if the magnitudes in the vertical and horizontal directions are very different, as they are for $h(x,y)$, 
the plots may be very concentrated in one direction. 
We therefore need to apply some auto-scaling procedure. 
In Figure ref{plotmayavi} two such procedures are exemplified.
In the first two plots the parameter `extent` is used. 
It tells Mayavi to auto-scale the surface and curve to fit the contents described 
by the six listed values (we will return to what these values mean when we have a more illustrating example).
Since the curve and the surface span different areas in space, we see that they are auto-scaled differently in the second plot, 
with the undesired effect that $\bm{r}(t)$ is not drawn on the surface. 
The last plot has avoided this problem by using the `warp_scale` parameter to scale in the vertical direction. 
Not all Mayavi functions accept this parameter. A remedy for this is to scale the $z$-coordinates manually, 
as here exemplified in the last `plot3d`-call. As is seen, the curve is drawn correctly with respect to the surface in the last plot. 
In the following we will use the `warp_scale` parameter to avoid such auto-scaling problems.



=== Subplots ===

The two plots in Figure ref{plotmayavi} were created as separate figures. One can also create them as subplots within one figure:

@@@CODE plot3d_mayavi.py from-to:# Create one figure with three subplots@# endsubplot
The result is shown in Figure ref{subplot}.
Three separate `mesh` commands are run, each producing a new plot in the current figure.
The commands use different values for the `colormap` attribute to color the surface in different ways.
When this attribute is not provided, as in the code producing the two first plots in Figure ref{plotmayavi}, a default colormap is used.

The `plt.outline` command is used to create a frame around the
subplots, and as seen, we exemplify this possibility for the last two
subplots, but not the first one.  We see that one of the two frames
has a different color, obtained by setting the `color` attribute of
the `plt.outline` command.

From the computer code it is hopefully clear that the six values listed in `extent` represent fractions of the cube `(0,1,0,1,0,1)`, where the corresponding plots are placed.
The extents for the three plots are here defined such that they do not overlap.

FIGURE:[fig/subplot, frac=1] A plot with three subplots created with Mayavi. label{subplot}



===== Contour plots =====

The following code exemplifies how one can produce contour plots with
Mayavi.  The code is very similar to that of Matplotlib, but one
difference is that the attribute `contours` now can represent the
number of levels, as well as the levels themselves.
The plots are shown in Figure ref{advancedcontourmayavi}.

@@@CODE plot3d_mayavi.py fromto:# Default contour plot plotted together with surf@#end contourplots
Note that there is no function in Mayavi which labels the contours.


Contour plots in Mayavi are shown in three-dimensional space, but you
can rotate and look at them from above if you want a two-dimensional
plot.  Their visual appearance may be enhanced by also including the
surface plot itself. We have done this for the top and middle left plots
in Figure ref{advancedcontourmayavi}.
There is a clear difference in visual impression between these
two plots: in the first one, default surface- and contour coloring is used,
resulting in less visible contours, but in the middle left plot (`plt.figure` 6), we set black contours to make them better stand out.

FIGURE:[fig/advanced_contour_mayavi, height=400 width=600 frac=0.8] Some contour plots with Mayavi. label{advancedcontourmayavi}



===== Vector field plots =====
label{plot:surf:mayavi:quiver}

Mayavi supports only vector fields in three-dimensional space.
We will therefore visualize the two-dimensional gradient field (ref{plot:surf:gradient:eq}) by adding a third component of zero.
The following code plots this gradient field  together with the contours of $h$.

@@@CODE plot3d_mayavi_manual.py from-to:# Draw contours and gradient field of h@# end draw contours and gradient field of h
This will produce a 3D view, which we again can rotate to obtain a 2D view.
The result is shown in Figure ref{plot:surf:may:quiver:fig}, which is similar to Figure ref{plot:surf:mpl:quiver:fig}.

FIGURE:[fig/quiver_mayavi_advanced, frac=1] Gradient field with contour plot. label{plot:surf:may:quiver:fig}











===== A 3D scalar field and its gradient field =====

Contrary to Matplotlib, Mayavi has functionality for drawing contours of 3D scalar fields.
Let us consider the 3D scalar field

!bt
\begin{equation} label{plot:surf:3D:surfeq}
g(x,y,z) = z-h(x,y).
\end{equation}
!et
A three-dimensional grid for $g$ can be computed as follows.

@@@CODE plot3d_mayavi.py from-to: # Define grid for 3D scalar field@# end define grid for 3D scalar field
The contours are now surfaces defined by the implicit equation $g(x,y,z)=C$,
corresponding to vertical shifts of the surface $h(x,y)$.

A corresponding vector field can be calculated:

!bt
\begin{equation}
\nabla g = \frac{\partial g}{\partial x}\bm{i} +  \frac{\partial g}{\partial y}\bm{j} +  \frac{\partial g}{\partial z}\bm{k}.
label{plot:surf:gradient:eq:3D}
\end{equation}
!et
`numpy`'s gradient function can be used to compute a gradient vector field in
3D as well, but you
need a three-dimensional grid for the field as input.
For the field (ref{plot:surf:3D:surfeq}), the gradient field is computed as follows.

@@@CODE plot3d_mayavi.py from-to: # Define grid for 3D gradient field@# end define grid for 3D gradient field
Again we have used a coarser grid for the vector field.

To visualize the field (ref{plot:surf:3D:surfeq}) and its gradient field together,
we draw enough contours, as we did in the 2D case in Figure ref{plot:surf:mpl:quiver:fig}.
The following code can be used.

@@@CODE plot3d_mayavi.py from-to:# Draw 3D vector field with countours of 3D scalar field@# end draw 3D vector field with countours of 3D scalar field
The result is shown in Figure ref{fig:quiver:mayavi}.

FIGURE:[fig/quiver_mayavi, frac=1] The 3D scalar field (ref{plot:surf:3D:surfeq}) and its gradient field. label{fig:quiver:mayavi}

This example demonstrates some of the challenges in plotting
three-dimensional vector fields.  The vectors must not be too dense,
and not too long.  It is inevitable that contours shadow for one
another. Fortunately, Mayavi supports an opacity setting, which
controls how contours are visible through each other.  Visualizing a
3D scalar field is clearly challenging, and we have only touched the
subject.





===== Animations =====

It is straightforward to create animations with Mayavi.
In the following code the function $h(x,y)$ is scaled vertically,
for different scaling constants between $0$ and $1$,
and each plot is saved in its own file.
The files can then be combined to one video, using appropriate software.

@@@CODE plot3d_mayavi.py from-to:# Create animation@# end create animation


% if MATLAB_TOO:

======= Matlab =======

===== Surface plots =====


The Matlab functions for producing surface plots of 2D scalar fields  are
`mesh` and `surf`. `mesh` produces a wireframe plot, while `surf`
colors the faces of the surface.
The function `plot3` can be used to plot parameterized curves.
The following code uses these functions to plot the surface and the curve.

@@@CODE plot3d_matlab.m fromto:% Simple plot of mountain@% endsimpleplots
We now needed to `hold` the plot, in order to place the plots in the same figure.
The code also illustrates how one can set a color map, and how we can adjust the thickness of a parametric curve.
The corresponding plots are shown in Figure ref{plotmatlab}.


FIGURE:[fig/plot_matlab] Two different plots of a mountain. The right plot also shows a trajectory to the top of the mountain. label{plotmatlab}




===== Contour plots =====
label{matlab:plot:surf:contours}

The following code exemplifies different ways contour plots
can be used to visualize the surface $h(x,y)$.

@@@CODE plot3d_matlab.m fromto: % Default two-dimensional contour plot@%end contourplots
The first three plots are shown in Figure
ref{simplecontourmatlab}. The first two are default 2D- and 3D visualizations. The third
displays the surface as an image, whose colors reflect the values of
the field, or equivalently, the height of the surface.
The next four plots appear in Figure
ref{advancedcontourmatlab}. They manually set the number of contours, their color, and their levels.
The last plot shows ho to label the contours.

FIGURE:[fig/simple_contour_matlab, frac=1]  Different types of contour plots of a 2D scalar field in two and three dimensions. label{simplecontourmatlab}

FIGURE:[fig/advanced_contour_matlab, height=400 width=600 frac=1] Some other contour plots: 10 contour lines (upper left), 10 black contour lines (upper right), specified contour levels (lower left), and labeled levels (lower right). label{advancedcontourmatlab}



===== Vector field plots =====
label{plot:surf:matlab:quiver}

The gradient field (ref{plot:surf:gradient:eq}) can be plotted together with the contours as follows

@@@CODE plot3d_matlab.m from-to:% Draw contours and gradient field of h@% end draw contours and gradient field of h
This resulting plot is shown in Figure ref{plot:surf:matlab:quiver:fig}.

FIGURE:[fig/quiver_matlab_advanced, frac=0.8] Gradient field with contour plot. label{plot:surf:matlab:quiver:fig}

% endif