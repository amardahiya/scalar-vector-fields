========= Plotting in three dimensions =========

We will explain plotting in three dimensions using three different packages. As with plotting in chapter 5, we will go through Matplotlib and SciTools. 
Then we will go through Mayavi, which contains support for doing more advanced plotting operations. The three packages are different in many respects, but they also have much in common, as code below shows. 
Note that, for most backends one can plug into Matplotlib/SciTools/Mayavi, one can rotate a figure by holding the mouse cursor down. This functionality is often useful in order to get a better view of a three-dimensional plot. 

Many of the plots below concern the following surface:

!bt
\[ h(x,y) = \frac{h_0}{1+ \frac{x^2+y^2}{R^2}}.\]
!et

This describes the height of an isolated mountain, where $h$ is the height above sea level, $x$ and $y$ are cartesian coordinates, $h_0$ is the height at the top of the mountain, and $R$ what is called the radius of the mountain. 
We will measure $h$ and $h_0$ in meters, and $R$ in kilometers. Prior to all code below we have set $h_0=2277$ and $R=4$. 

Prior to plotting the function $h(x,y)$, we need create a grid of the points to plot. This can be done regardless of which plotting package we will use later as follows.  

!bc pycod
t = np.linspace(-10., 10., 41)
x, y = np.meshgrid(t, t, indexing='ij', sparse=False) # # Grid for contour plot
h = h0/(1 + (x**2 + y**2)/(R**2)) # Compute the elevation coordinates
!ec
We here defined a grid for the area closer to the mountain top than 10km in any direction.
Note the mysterious extra parameters to `meshgrid` here, which are needed in order for the coordinate axes to have the order we would expect in mathematics.
`indexing='ij'` means that the coordinates are set as in an $xy$-coordinate system.
`indexing='xy'` means that the coordinates are set as row/column indices in a matrix.

We will also plot the gradient vector field of $h(x,y)$. This can be computed using the function `np.gradient` as follows. 

!bc pycod
t2 = np.linspace(-10.,10.,21)
x2, y2 = np.meshgrid(t2, t2, indexing='ij', sparse=False) # Grid for vector field     
h2 = h0/(1+(x2**2+y2**2)/(R**2)) 
dhx, dhy = np.gradient(h2)         # Compute the gradient vector (dh/dx,dh/dy)
!ec

Not that here we created a new grid for the coordinates of the gradient vectors. The reason is that we will plot many vectors at the same time, so that it may be smart to use a smaller resolution for the 
vector field coordinates than for the surface coordinates.

We will also plot another vector field defined as follows.

!bt
\[\bm{v} = \left( x^2 + 2y - \frac{1}{2}Â xy \right)\bm{i}  - 3y\bm{j}.\]
!et
We will plot this over $[-5,5]$, with $0.5$ distance between the vectors. The grid can now be obtained as follows.

!bc pycod
t = np.linspace(-5, 5, 11)
x, y = np.meshgrid(t, t, sparse=False, indexing='ij')
vx = x**2 + 2*y - .5*x*y
vy = -3*y
!ec







======= Matplotlib =======

Below we will use the prefix `plt` for the package `matplotlib.pyplot`:

!bc pycod
import matplotlib.pyplot as plt
!ec

Note that with Matplotlib, after each plot command you need to write `plt.show()` in order for the new plot to become visible.


===== Simple surface plots =====

The surface $h(x,y)$ can be plotted as follows:

!bc pycod
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_surface(x, y, h)
!ec

The result is shown in the left plot in Figure ref{plotmatplotlib}.

FIGURE:[images/plotmatplotlib] Two Matplotlib surface plots. Plot without colours (left), and a plot with colours (right) shown together with a parametric curve which is a trajectory to the top of the mountain. label{plotmatplotlib}

Coloring can be used to get a better view of surfaces. We can use the `cm`-module to obtain a color map which can be used to color the surface.

!bc pycod
from matplotlib import cm
!ec

This can then be passed to the `plot_surface` function above as follows:

!bc pycod
ax.plot_surface(x, y, h, cmap=cm.coolwarm)
!ec

The result is shown in the right plot in Figure ref{plotmatplotlib}. One can choose from a wide range of different color maps.

Several curves and surface can be included in the same plot. The previously produced surface had been combined with a plot of a parametrized curve. This curve lies on the surface,
which moves with constant angular and radial velocity towards the top of the mountain (i.e. it represents a climb to the top of the mountain).
This curve can be produced as follows.

!bc pycod
t = np.linspace(0, 2*np.pi, 100)
xcoords = 10*(1 - t/(2*np.pi))*np.cos(t)
ycoords = 10*(1 - t/(2*np.pi))*np.sin(t)
zcoords = h0/(1 + 100*(1 - t/(2*np.pi))**2/(R**2))
!ec

and the following command plots the curve

!bc pycod
ax.plot(xcoords, ycoords, zcoords)
!ec

===== Contour plots =====

The following code examplifies how one can create different types of contour plots.

!bc pycod
plt.contour(x, y, h)        # default: with X contour lines
plt.contour(x, y, h, 10)    # 10 contour lines. The contour levels will be automatically chosen.
plt.contour(x, y, h, 10, colors='k')   # 10 contour lines. Black color for contour lines
levels = [500., 1000., 1500., 2000.]
plt.contour(x, y, h, levels=levels)   # specify the contour levels
# Add labels with the contour line values to the lines
c = plt.contour(x, y, h, levels=levels)
plt.clabel(c)
!ec

The default contour plot is shown in Figure ref{simplecontourmatplotlib}. The remaining 4 plots are shown in Figure ref{advancedcontourmatplotlib}.

FIGURE:[images/simplecontourmatplotlib, height=400 width=600 frac=0.8]  Default contour plot with Matplotlib. label{simplecontourmatplotlib}

FIGURE:[images/advancedcontourmatplotlib, height=400 width=600 frac=0.8] Some other contour plots with Matplotlib: With 10 contour lines (upper left), with 10 contour lines in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourmatplotlib}


===== Plotting vector fields =====

The following code plots the vector field $\bm{v}$ defined above. 

!bc pycod
plt.quiver(x, y, vx, vy, angles='xy', scale_units='xy', color='b')
!ec

The two first parameters specify the $x$- and $y$-components of the points where vectors are to be drawn, and the next two parameters the actual components of the vectors.
The result is shown in the left plot in Figure ref{quivermatplotlib}

FIGURE:[images/quivermatplotlib, height=400 width=600 frac=0.8] A vector field plotted with Matplotlib (left), and contours together with the gradients (right). label{quivermatplotlib}


The parameters `angles` and `scale_units` say that the vector field should be drawn as a gradient field, i.e. that the length of the vectors coincide with that of the vector $\bm{v}$.
`color` indicates the colour to be used for the vectors (here blue).
Often the vectors need to be scaled in order for them not to collide in the plot (alternatively one can have some more distance between the points in the arrays `x` and `y`.
This can be done manually by using the `scale` parameter. Increasing this results in shorter vectors. 
Matplotlib will attempt to scale the plot automatically if the `scale` parameter is not set, in order to try to avoid that the vectors collide.

Let us finally see how to plot the contour lines of $h(x,y)$ together with its gradient field. The following three lines do the job, once all grid coordinates and the gradient field have been computed as above. 

!bc pycod
plt.quiver(x2, y2, dhx, dhy, color='r', angles='xy')               
plt.hold('on')
plt.contour(x, y, h)
!ec
The result is shown in the right plot in Figure ref{quivermatplotlib}. In calculus one is taught that the gradients are orthogonal to the contour lines. This is easily seen in the plot.  




======= SciTools =======

The plots generated with SciTools below have been generated with the default backend of SciTools, which is Matplotlib in the most recent versions of SciTools.  
Below we will use the prefix `plt` for the package `scitools.easyviz`:

!bc pycod
import scitools.easyviz as plt
!ec

[TODO: Curve plots in 3D using SciTools]

===== Simple surface plots =====

SciTools has the function `ndgrid` which, just as `meshgrid`, can be used to create grids of all possible $(x,y)$-coordinate pairs from given one-dimensional coordinates.
One can simply replace the calls to `meshgrid` above with

!bc pycod
x, y = plt.ndgrid(t, t)     # Grid for contour plot
x2, y2 = plt.ndgrid(t2, t2) # Grid for quiver plot
!ec

`ndgrid` is more flexible than `meshgrid` in the sense that it can be used to make three-dimensional grids also. Also, we see that the extra parameters `indexing` and `sparse` do not need to be set: They attain default values which can be used.

The surface can be plotted simply by writing `plt.mesh(x, y, h)`, so that this part of the code is shorter than the three lines needed with Matplotlib.
The result is shown in the left plot in Figure ref{plotscitools}.

FIGURE:[images/plotscitools, height=400 width=600 frac=0.8] Two SciTools surface plots. Simple plot (left), and a plot with colours (right). label{plotscitools}

We can write `plt.surf(x, y, h)` instead of `plt.mesh(x, y, h)` to get a graph where the surface elements have been coloured. 
The result is shown in the right plot in Figure ref{plotscitools}. One can choose from a wide range of different color maps. 

===== Contour plots =====

The following code examplifies how one can create the same types of contour plots as above with SciTools. As is seen, there are only minor differences in how the parameters (colour, levels, labeling) to the plot are set

!bc pycod
plt.contour(x, y, h)        # default: with X contour lines
plt.contour(x, y, h, 10)    # 10 contour lines. The contour levels will be automatically chosen.
plt.contour(x, y, h, 10, 'k')   # 10 contour lines. Black color for contour lines
levels = [500., 1000., 1500., 2000.]
plt.contour(x, y, h, levels)   # specify the contour levels
plt.contour(x, y, h, levels, clabels='on') # Add labels with the contour line values to the lines
!ec

The default contour plot is shown in Figure ref{simplecontourscitools}. The remaining 4 plots are shown in Figure ref{advancedcontourscitools}.

FIGURE:[images/simplecontourscitools, height=400 width=600 frac=0.8]  Default contour plot with SciTools. label{simplecontourscitools}

FIGURE:[images/advancedcontourscitools, height=400 width=600 frac=0.8] Some other contour plots with SciTools: With 10 contour lines (upper left), with 10 contour lines in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourscitools}

===== Plotting vector fields =====

The following code plots the vector field $\bm{v}$ defined above. 

!bc pycod
plt.quiver(x, y, vx, vy, 200, 'b')
!ec

[TODO: I need to consult the documentation here]
The two last parameters represent scaling and color. The resulting plot is shown in Figure ref{quiverscitools}

FIGURE:[images/quiverscitools, height=400 width=600 frac=0.8] A vector field plotted with SciTools (left), and contours together with the gradients (right). label{quiverscitools}

Let us round off by considering again the previous example of contour/gradient plot. The following three lines do the job in this case, and the result is shown in the right plot in Figure ref{quiverscitools}.

!bc pycod
plt.quiver(x2, y2, dhx, dhy, 0, 'r')
plt.hold('on')     
plt.contour(x, y, h, daspectmode='equal') 
!ec







======= Mayavi =======

Mayavi[^mayaviurl] is an advanced, free, easy to use, scientific data visualizer, with an emphasis on 3D visualization. 
It is written in Python, and uses the Visualization Toolkit (VTK) for rendering graphics. Since VTK can be configured with different backends, so can Mayavi. 
Mayavi is cross platform and should run on any platform where both Python and VTK are available (this includes Mac OSX and Windows).

There are several ways you can obtain a full environment for Mayavi.

[^mayaviurl]: The page URL: "http://docs.enthought.com/mayavi/mayavi/" collects pointers to all relevant documentation or Mayavi

We recommend that you use Anaconda for Mayavi, since Anaconda is cross-platform. This requires that you install a list of packages which Mayavi depends on[^mayavipackagesurl]
These are not only Python packages (which thus can be installed with `pip`), but also other types of dependencies
(which can be installed with `conda`, a package managament tool which handles dependencies which are outside Python, contrary to `pip`. `conda`, just as `pip`, is bundled with your Anaconda installation).

You can install Canopy[^canopyurl]. Canopy contains a full Python environment, and through the package manager tool of Canopy you can install Mayavi itself, VTK, and all the other dependencies of Mayavi.
The package manager tool gives you access to install not only Mayavi, but also a whole list of packages from what is called a package index.

[^canopyurl]: URL: "https://www.enthought.com/products/canopy/"
[^mayavipackagesurl]: A list of the packages you need can be found on URL: "http://docs.enthought.com/mayavi/mayavi/installation.html"

You can also use Ubuntu and the VMWare Fusion virtual machine, and install all components by hand (see the link for Anaconda to package dependencies).

We will only consider the Mayavi-functionality for simple plotting[^simpleplotting], such as the functionality we considered for Matplotlib and SciTools.
The `mayavi.mlab` module provides a simple interface to such plotting, with an emphasis on 3D visualization.
Below we will use the prefix `plt` for the package `mayavi.mlab`:

!bc pycod
import mayavi.mlab as plt
!ec
Several of the functions in `mlab` have the same name as the counterparts in SciTools and Matplotlib, so it is smart to separate them using prefixes.

[^simpleplotting]: The documentation for simple plotting functions can also be found on URL: "http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html". Further documentation can be found on URL: "http://docs.enthought.com/mayavi/mayavi/auto/mlab_other_functions.html".

===== The basics =====

We first need to cover some of the basic figure handling function in the `mayavi.mlab` module[^basicfigurehandling].
Much of this is similar to the bascis for Matplotlib and SciTools, and we will therefore try to focus mainly on the differences.

[^basicfigurehandling]: The documentation for basic figure handling functions can be found on URL: "http://docs.enthought.com/mayavi/mayavi/auto/mlab_figure.html"

The plotting commands you do in `mlab` will go to the current figure, also called a scene. This means that several plot commands will be shown together.
You can work with several figure instances simultaneously. A figure can be accessed in three different ways:

o as a `Figure` object representing it,
o by a name representing it,
o by a number representing the index of the plot

When either a Figure object, a name or an integer is supplied as parameter to the function `plt.figure()`, `mlab` sets the current figure to be that particular Figure object, 
or the Figure object with that name or index. If no figure existed with the given name/index, a new figure object will be created with that name/index, and set as the current figure.  

[TODO: Include this more general description of the usage of figure() in chapter 5 instead? This is a more natural place for this, as it is nice to know how to jump between a set of figures.]

In the same way, the function `plt.close()` closes a figure with the given handle, name, or index. 
To clear (not close) the current figure before the next plot, we can run the command `plt.clf()`. 
The function `plt.gcf()` returns the current figure object. You will need to call this in order to get the object where you can set some the figure properties, 
such as the foreground or background colour (the foreground colour is used for text and labels included in the plot). This can also be done directly by writing

!bc pycod
plt.figure(fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0))
!ec
Here colours are represented as RGB-values, where the components are floating points between zero and one. In the above code the foreground and background colour
for the current figure is set to black and white, respectively.

Many of the other functions are also similar to what we are used to.

* `plt.savefig(filename)` saves the current figure to file. The type of the file (png, jpeg, etc) is deduced fom the file extension  
* `plt.show()` makes the current figure visible (it may be that the environment does this by itself).
* `plt.title()` to decorate the current figure  with a title.
* `plt.axes()` for creating axes with labels and given colors, we can use the function plt.axes(xlabel='x', ylabel='y')

The following code examplifies all the above in one plot.

!bc pycod
plt.clf() # Clear
# Create figure with white background, black foreground
plt.figure(fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0)) 
... Create and plot your figure
plt.title('My first plot')
plt.axes(xlabel='x', ylabel='y', zlabel='z', nb_labels=5, color=(0., 0., 0.))
plt.show()
plt.savefig('plot.png')
!ec



===== Simple surface plots and subplots =====

Let us return to plotting the surface $h(x,y)$. Mayavi also has commands `mesh` and `surf`, which works similarly to Matplotlib and SciTools:

!bc pycod
plt.mesh(x, y, h)
plt.surf(x, y, h)
!ec
Both functions color the surface, and accept many of the same parameters. For some purposes `surf` seems to be more general.
The left plot of figure ref{plotmayavi} shows the result when `mesh` is used.

FIGURE:[images/plotmayavi] Two Mayavi surface plots. Using `mesh` (left), and using `surf` (right). The right plot also shows our parametrized curve. label{plotmayavi}

If the magnitudes in the vertical and horizontal directions are very different, the plots above will whow a plot which is very concentrated in one direction.
The reason is that Mayavi does no auto-scaling of the axes per default (corresponding to `axis("equal")` in Matplotlib and Matlab). To ensure
that the axes are auto-scaled to fit the contents of the surface one can include the parameter `extent` in the following way

!bc pycod
plt.surf(x, y, h, extent=(0, 1, 0, 1, 0, 1))
!ec
Below we will return to what the six values in `extent` mean.
Note that the behaviour may be unexpected when combining different plots which both have been auto-scaled.
To illustrate this let us also autoscale our parametrized curve, obtained by climbing the mountain so that the angular speed is constant.
For this we can use the `plot3d` command as folllows.

!bc pycod
plt.plot3d(xcoords, ycoords, zcoords, tube_radius=0.2)
!ec
The additional parameter `tube_radius` controls the width of the parametrized curve, and was increased here in order to make the curve more visible when shown together with `surf`.
The right plot of figure ref{plotmayavi} shows the result when both `surf` and `plot3d` are combined in the same plot. We see that the curce does not lie on the surface, as it should.
The reason is that the ranges of the $x$-, $y$-, and $z$-values differ for the the curve and the surface, so that autoscaling will use different scales when placing them on the scene.
We therefore have to be a bit cautious when applying the autoscaling in Mayavi, and in the following contour plots we will avoid this autoscaling problem by scaling everything
first so that the coordinates are of comparable magnitude, so that there is no need for autoscaling in the first case.

One can also use other properties to scale the cases. Some of the plotting commands below accept a `warp_scale` parameter, which tells us how the the vertical scaling should be performed.

The two plots in figure ref{plotmayavi} were created as separate figures. One can also create them as subplots within one figure, so that one figure is generated with several subplots.
Consider the following code.

!bc pycod
plt.outline(plt.mesh(x, y, h, extent=(0, 0.25, 0, 0.25, 0, 0.25), \\
           color=(.5, .5, .5)))
plt.outline(plt.mesh(x, y, h, extent=(0.375, 0.625, 0, 0.25, 0, 0.25), \\
           colormap='Accent'))
plt.outline(plt.mesh(x, y, h, extent=(0.75, 1, 0, 0.25, 0, 0.25), \\
           colormap='prism'))
!ec
The result is shown in the left plot in Figure ref{subplot}.


FIGURE:[images/subplot] A plot with three subplots created with Mayavi, consisting of the same surface drawn with different color maps. label{subplot}

From this it should be clear that the six values listed in `extent` represent fractions of the cube `(0,1,0,1,0,1)`, where the corresponding plots are placed.
The extents for the three plots are defined so that they do not overlap.
Three separate `mesh` commands are run, each producing a new plot in the current figure.
The handles to the three plots are stored in the variables `surf1`, `surf2`, and `surf3`, and
the function `outline` finally draws the corresponding box for the plot in question. We have dropped the axes and the title in the code here.

Note that the surfaces in Figure ref{subplot} are drawn with different colors. This is due to the `colormap` and `color` attributes in the call to `mesh`, which adjusts the colors when the surface is drawn. The `color` attribute, which we see also can be used as a
parameter to `outline`, adjusts the surface so that it is colored with small variations from the provided base-color.
One can choose from a wide range of different color maps.


===== Contour plots =====

The following code examplifies how one can create the same types of contour plots as above with Mayavi. We see again some minor differences, such as how colors here are specified by value.   

!bc pycod
plt.contour_surf(x, y, h)        # default: with X contour lines
plt.contour_surf(x, y, h, contours=10)    # 10 contour lines. The contour levels will be automatically chosen.
plt.contour_surf(x, y, h, contours=10, color=(0., 0., 0.))   # 10 contour lines. Black color (i.e. (0., 0., 0.)) for contour lines
levels = [500., 1000., 1500., 2000.]
plt.contour_surf(x, y, h, contours=levels)   # specify the contour levels
!ec

There seems to be no function in Mayavi which labels the contours, as we did with Matplotlib and ScitTools. 
[TODO: I can't find out out how to set label text as in clabel]
The plots are shown in Figure ref{advancedcontourmayavi}. Contour plots in Mayavi are shown in 3D, contrary to Matplotlib and SciTools. Their visual appearance may be enhanced by also including the surface plot itself. We have here done this for two of the contour plots. 
For comparison, we have not included the surface itself for the two last contour plots. There is a clear difference in visual impression between the two, and we see that the colour of the contours can conflict with the colour of the surface.

FIGURE:[images/advancedcontourmayavi, height=400 width=600 frac=0.8] Some contour plots with Mayavi: Default contour plot (upper left), with 10 contour lines (upper right), with 10 contour lines in black (lower left), and with specified levels (lower right). label{advancedcontourmayavi}




===== Plotting vector fields in 3D =====

Mayavis functionality for plotting vector fields is primarily intended for 3D also. As an example, let us attempt to plot a gravitational field.
Newtons law of gravitation says that the gravitational force is proportional to

!bt
\[-\bm{r}/|\bm{r}|^3 = -( x,y,z)/\sqrt{x^2+y^2+z^2}^3,\]
!et
where $\bm{r}=(x,y,z)$ is the position vector. Let us attempt to plot this vector field. 
We need a three-dimensional grid, so that `meshgrid` will not work. We can either use `ndgrid` from SciTools, or `mgrid` from `numpy` as follows
If we want to plot this over $[-5,5]$, with $0.5$ distance between the vectors, we first need to create a two-dimensional grid as follows.

!bc pycod
x, y, z = np.mgrid[.5:2:.2, .5:2:.2, .5:2:.2]
r3 = np.sqrt(x**2 + y**2 + z**2)**3
vx = -x/r3
vy = -y/r3
vz = -z/r3
!ec
The cube of the distance (`r3`) has here been computed once, since all three components are divided by this.
Also we compute the vector field for a section in the first octant only, where all three components are between $0.5$ and $2$, and we do not make the grid too dense, so that individual vectors have smaller chance of colliding.
The vector field can now be vizualized as follows.

!bc pycod
plt.figure(fgcolor=(.0, .0, .0), bgcolor=(1.0, 1.0, 1.0)) 
plt.quiver3d(x, y, z, -x/r3, -y/r3, -z/r3, \\
            mode='arrow', colormap='jet', scale_factor=.5)
plt.axes(xlabel='x', ylabel='y', zlabel='z', \\
        nb_labels=5, color=(0., 0., 0.))

!ec
The three first parameters to `quiver3d`, the function which actually plots the vector field, specify the $x$-, $y$-, and $z$-components of the points where vectors are to be drawn.
The next three parameters are the actual components of the vectors.
To improve the visualization of the field, we have set some of the optional properties to `quiver3d`:

* The `mode` parameter ensures that the vectors are drawn as arrow.
* The `colormap` parameter controls how the vectors are colored.
* The `scale_factor` parameter lets us manually scale the vector lengths, to ensure that they do not collide.

In addition we have set a foreground and background color for the figure, and added axes as above.
The resulting plot is shown in Figure ref{quivermayavi}. This shows some of the challenges in plotting vector fiels in 3D dimensions. It may be challenging to create instructive plots, since vectors are drawn over an area in 3D rather than 2D.

FIGURE:[images/quivermayavi, height=400 width=600 frac=0.8] A vector field plotted with Mayavi. label{quivermayavi}

===== Animations =====


We have previously seen how to produce animations with Matplotlib and SciTools.
With the function `animate` in `mlab` we can also create animations.



This code will rotate the camera continuously. f is the current graphics.

!bc pycod
import mayavi as plt
@mlab.animate
def anim():
    f = plt.gcf()
    while 1:
        f.scene.camera.azimuth(10)
        f.scene.render()
        plt.yield

a = anim()
!ec