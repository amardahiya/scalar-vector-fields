======= Examples on plotting of scalar and vector fields =======
label{plot:surf}

Visualization of scalar and vector fields in Python is commonly done
using Matplotlib or Mayavi. Both packages support basic visualization of
2D scalar and vector fields, but Mayavi offers more advanced
three-dimensional visualization techniques,
especially for 3D scalar and vector fields.

One can also use SciTools for visualizing 2D scalar and vector
fields, using either Matplotlib, Gnuplot, or VTK as plotting engines, but
this topic is omitted from the present book.
However, for fast visualization of 2D
scalar fields, Gnuplot is a viable tool, and the SciTools interface
offers a Matlab-style set of commands to operate Gnuplot.

To exemplify visualization of scalar and vector fields with Matplotlib
and Mayavi, we use a common set of examples. A scalar function of $x$
and $y$ is visualized either as a flat two-dimensional plot with
contour lines of the field, or as a three-dimensional surface where
the height of the surface corresponds to the function value of the
field. In the latter case we also add a three-dimensional
parameterized curve to the plot.

To illustrate plotting of vector fields, we simply plot the gradient of the scalar field (often together with the scalar field).
Our convention for variable names goes as follows:

* `x`, `y`, `z` for one-dimensional coordinates along each axis direction.
* `xv`, `yv`, `zv` are corresponding
  vectorised coordinates in a 2D or 3D grid.
* `u`, `v`, `w` are the components of a vector field
  at points corresponding to `xv`, `yv`, `zv`.

The following sections contain more mathematical details on the various
scalar and vector fields we aim to plot.
#Most figures in this context
#we generated by Matplotlib.  Succeeding sections explain the
#corresponding code and how the same plots can be made with Mayavi.


===== Installation =====
label{plot:surf:install}

Previously in the book we have explained how to obtain Matplotlib for various platforms.
To obtain Mayavi on Ubuntu platforms you can write

!bc sys
pip install mayavi --upgrade
!ec
For Mac OS X and Windows, we recommend using Anaconda.
To obtain Mayavi for Anaconda you can write

!bc sys
conda install mayavi
!ec




===== Surface plots =====
label{plot:surf:mesh_surf}

We consider the 2D scalar field defined by

!bt
\begin{equation}
h(x,y) = \frac{h_0}{1+ \frac{x^2+y^2}{R^2}}.
label{plot:surf:heq}
\end{equation}
!et
$h(x,y)$ may model the height of an isolated circular mountain,
$h$ being the height above sea level,
while $x$ and $y$ are Cartesian coordinates on the earth's surface,
$h_0$ the height of the mountain, and $R$ the radius of the mountain.
Since mountains are actually quite flat (or more precisely,
their heights are small compared to the horizontal extent), we use
meter as length unit for vertical distances ($z$ direction) and km as length
unit for horizontal distances ($x$ and $y$ coordinates).
Prior to all code below we have initialized $h_0$ and $R$ with
the following values:

@@@CODE plot3d_matplotlib.py fromto: h0 =@#endinitvalues

=== Grid for 2D scalar fields ===

Before we can plot $h(x,y)$, we need to create a rectangular grid in the $xy$ plane with all the points used for plotting. Regardless of which plotting package we will use later on, the grid can be made as follows:

@@@CODE plot3d_matplotlib.py fromto: # Grid for x, y@# endinitgrid
The grid is based on equally spaced coordinates `x` and `y` in the
interval $[-10,10]$ km.
Note the mysterious extra parameters to `meshgrid` here, which are needed in order for the coordinates to have the right order in mathematics.

A surface plot of a 2D scalar field $h(x,y)$ is a visualization of the surface $z=h(x,y)$ in three-dimensional space.
Most plotting packages have functions which can be used to create surface plots of 2D scalar fields.
These can be either *wireframe plots*, where only lines connecting the grid points are drawn,
or plots where the faces of the surface are colored.
In Figure ref{plotmatplotlib} we have shown two such plots of the surface $h(x,y)$. Section ref{matplotlibsurfaceplots} presents the code which generates these plots.

FIGURE:[fig/plot_matplotlib] Two different plots of a mountain. The right plot also shows a trajectory to the top of the mountain. label{plotmatplotlib}

===== Parameterized curve =====
label{plot:surf:3Dcurve}

To illustrate the plotting of three-dimensional parameterized curves,
we consider a trajectory that represents a circular climb to the top
of the mountain:

!bt
\begin{equation}
\bm{r}(t) = \left( 10\left(1 - \frac{t}{2\pi}\right)\cos(t) \right) \bm{i} + \left( 10\left(1 - \frac{t}{2\pi}\right)\sin(t) \right) \bm{j} + \frac{h_0}{1 + \frac{100(1 - t/(2\pi))^2}{R^2}} \bm{k}. label{plot:surf:req}
\end{equation}
!et
Here $\bm{i}$, $\bm{j}$, and $\bm{k}$ denote the unit vectors in the $x$-, $y$-, and $z$-directions, respectively.
The coordinates of $\bm{r}(t)$ can be produced by

@@@CODE plot3d_matplotlib.py fromto: s = np.linspace@# endparamcurve
The parameterized curve is shown together with the surface $h(x,y)$ in the right plot in Figure ref{plotmatplotlib}.


===== Contour lines =====
label{plot:surf:contours}

Contour lines are lines defined by the implicit equation $h(x,y)=C$, where
$C$ is some constant representing the contour level.
Normally, we let $C$ run over some equally spaced values, and very often, the
plotting program computes the $C$ values.
To distinguish contours, one often associates each contour level $C$ with its own color.

Figure ref{simplecontourmatplotlib} shows different ways contour lines
can improve the visualization for the surface $h(x,y)$.  The first and
last plot are visualizations utilizing two spatial dimensions.  The
first draws a small set of contour lines only, while the last one
displays the surface as an image, whose colors reflect the values of
the field, or equivalently, the height of the surface.  The third plot
actually combines three different types of contours, each type
corresponding to keeping a coordinate constant and projecting the
contours on a ``wall''.  The code used to generate these plots is
presented in Section ref{matplotlibcontourplots}.

FIGURE:[fig/simple_contour_matplotlib, frac=1]  Different types of contour plots of a 2D scalar field in two and three dimensions. label{simplecontourmatplotlib}

===== The gradient vector field of $h$ =====
label{plot:surf:gradient}

The *gradient vector field* $\nabla h$ of a 2D scalar field $h(x,y)$ is defined by

!bt
\begin{equation}
\nabla h = \frac{\partial h}{\partial x}\bm{i} +  \frac{\partial h}{\partial y}\bm{j}.
label{plot:surf:gradient:eq}
\end{equation}
!et
One learns in vector calculus that the gradient points in the direction where $h$ increases most, and
that the gradients are orthogonal to the contour lines.
This is something we can easily illustrate by creating 2D plots of the contours and the gradient field.
A challenge in making such plots is to get the right arrow lengths so
that the arrows are well visible, but they do not collide and make a
cluttered visual impression. Since the arrows are drawn at each point in
a 2D grid, one way of controlling the number of arrows is to control
the resolution of the grid. So, let us use a grid with 20 instead of 40 intervals in the horizontal
directions:

@@@CODE plot3d_matplotlib.py fromto: # Define a coarser grid for the vector field@# endcoarsergrid
The gradient vector field of $h(x,y)$ can now be computed using the function `np.gradient`:

@@@CODE plot3d_matplotlib.py fromto: dhdx, dhdy@# endgradient
The gradient field (ref{plot:surf:gradient:eq}) together with the contours appear in Figure ref{plot:surf:mpl:quiver:fig},
from which the orthogonality can be easily seen.
Section ref{plot:surf:mpl:quiver} explains the code needed to make this plot.

FIGURE:[fig/quiver_matplotlib_advanced, frac=0.8] Gradient field with contour plot. label{plot:surf:mpl:quiver:fig}

Note that the values in a scalar field may be of another magnitude than the values in its gradient field.
This is the case for the field here, even after using different units (meters and kilometers) in the horizontal and vertical directions.
We have to take this into account when plotting the two fields together.
Plotting packages have several attributes which can be set to address this.
In the code we have instead addressed this problem by scaling the mountain so that the values in the vertical and horizontal directions are of comparable magnitude,
resulting in values of comparable size in the scalar- and gradient fields.



===== A 3D scalar field =====
label{sec:3Dscalar}

Let us consider the 3D scalar field

!bt
\begin{equation} label{plot:surf:3D:surfeq}
g(x,y,z) = z-h(x,y).
\end{equation}
!et
A three-dimensional grid for $g$ can be computed as follows.

@@@CODE plot3d_mayavi.py fromto: # Define grid for 3D scalar field@# end define grid for 3D scalar field
Contours are useful also for visualization of 3D scalar fields.
The contours are now three-dimensional curves defined by the implicit equation $g(x,y,z)=C$.










===== Gradient vector fields of 3D scalar fields =====
label{sec:3Dgradient}

Gradient fields can be defined in higher dimensions also. In particular, the gradient of $g$ is defined by

!bt
\begin{equation}
\nabla g = \frac{\partial g}{\partial x}\bm{i} +  \frac{\partial g}{\partial y}\bm{j} +  \frac{\partial g}{\partial z}\bm{k}.
label{plot:surf:gradient:eq:3D}
\end{equation}
!et
`numpy`'s gradient function can be used to compute a 3D gradient vector field as well.
You need a three-dimensional grid for the field as input.
For the field (ref{plot:surf:3D:surfeq}), the gradient field is computed as follows.

@@@CODE plot3d_matplotlib.py fromto: # Define grid for 3D gradient field@# end define grid for 3D gradient field
Again we have used a coarser grid for the vector field.

[hpl: The text below does not make sense to me, because there is not
intuitive justification of the usefullness of this 3D vector field, and
I am not aware of any physical applications of it either. It's a math property,
but when are students supposed to look up the recipe for plotting the
normal vector field of a scalar field? There must be a motivation
for bringing in a new concept.]
One learns in vector calculus that, also for dimensions higher than $2$,
the gradient field points in the direction of maximum increase, and is orthogonal to the contours.
For $g$ this is an orthogonality in three-dimensional space.
Clearly we have that

!bt
\[
\nabla g(x,y,z) = -\frac{\partial h}{\partial x}\bm{i}  -\frac{\partial h}{\partial y}\bm{j} + \bm{k},
\]
!et
and the contour defined by $g(x,y,z)=0$ corresponds to points on the form $(x,y,h(x,y))$, i.e. points on the surface $h$
(the other contours are simply vertical shifts of $h$).
The stated result from calculus thus says that, for points on the surface, $\nabla g(x,y,z)$ is orthogonal to the surface.
The restriction of $\nabla g$ to the surface is therefore also called  the *normal vector field* of $h$.
In Figure ref{quivercontoursurfmatplotlib} we have plotted the normal vector field, together with the contours and the surface.
Again the code can be found in Section ref{plot:surf:mpl:quiver}.

FIGURE:[fig/quiver_contour_surf_matplotlib, height=400 width=600 frac=1] Normal vector field with contours (left), with surface (right). label{quivercontoursurfmatplotlib}

[hpl: There are references to a field (ref{plot:surf:3D:surfeq}), but not formula. Is this the gravity field you removed? Need to search for and clean up references to it.]
To visualize the field (ref{plot:surf:3D:surfeq}) and its gradient field together,
we draw enough contours, as we did in the 2D case in Figure ref{plot:surf:mpl:quiver:fig}.
The result is shown in Figure ref{fig:quiver:matplotlib}.
In Section ref{plot:surf:mpl:quiver} we go through the corresponding code.
Visualizing a 3D scalar field is clearly challenging, and we shall only touch the subject.

FIGURE:[fig/quiver_matplotlib, frac=1] The 3D scalar field (ref{plot:surf:3D:surfeq}) and its gradient field. label{fig:quiver:matplotlib}

[hpl: No references to Figure ref{fig:quiver:matplotlib}. Why is it included?]

======= Matplotlib =======

We import any visualization package under the name `plt`, so
for Matplotlib the import is done by

!bc pycod
import matplotlib.pyplot as plt
!ec
When creating two-dimensional plots of
scalar and vector fields, we shall make use
of a Matplotlib `Axes` object, named `ax` and made by

!bc pycod
fig = plt.figure(1)   # Get current figure
ax = fig.gca()        # Get current axes
!ec
For three-dimensional visualization, we need the following alternative
lines:

!bc pycod
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(1)
ax = fig.gca(projection='3d')
!ec

===== Surface plots =====
label{matplotlibsurfaceplots}

The Matplotlib functions for producing surface plots of 2D scalar fields  are
`ax.plot_wireframe` and `ax.plot_surface`.
The first one produces a wireframe plot, and the second one colors the faces of the surface.
The following code uses the functions to produce the plots shown in Figure
ref{plotmatplotlib}, once the grid has been defined as in Section ref{plot:surf:mesh_surf},
and the coordinates of the parameterized curve have been computed as in Section ref{plot:surf:3Dcurve}.

@@@CODE plot3d_matplotlib.py fromto:# Simple plot of mountain@# endsimpleplots
Recall that a final
`plt.show()` command is necessary to force Matplotlib to show a plot on the screen.

Note that the second plot in this figure is drawn using a finer grid.
This is controlled with the `rstride` and  `cstride` parameters, which sets the number of grid lines in each direction.
Setting one of these to 1 means that a grid line is drawn for every value in the grid in the corresponding direction,
and setting to 2 means that a grid line will be drawn for every second value in the grid.

A surface with colors reflecting the height of the surface (i.e. the
value of the scalar field) needs specification of a *color map*, i.e.
a mapping between function values and colors.
Above we applied the common `coolwarm`
scheme which goes from blue (``cool'' color for minimum values) to red
(``warm'' color for maximum values), as well as another scheme called
`Spectral`.  There are lots of colormaps to choose from, and you have
to experiment to find appropriate choices according to your taste and
to the problem at hand.

To the latter plot we also added the parameterized curve $\bm{r}(t)$,
defined by (ref{plot:surf:req}), using the command `plot`.  The
attribute `linewidth` was increased here in order to make the curve thicker and
more visible.  By default, Matplotlib adds plots to each other without
any need for `plt.hold('on')`, although such a command can indeed be
used.



===== Contour plots =====
label{matplotlibcontourplots}

The following code exemplifies different types of
contour plots.  The first two plots (default two-dimensional and
three-dimensional contour plots) are shown in Figure
ref{simplecontourmatplotlib}. The next four plots appear in Figure
ref{advancedcontourmatplotlib}.


@@@CODE plot3d_matplotlib.py fromto: # Default two-dimensional contour plot@#end contourplots

FIGURE:[fig/advanced_contour_matplotlib, height=400 width=600 frac=0.8] Some other contour plots with Matplotlib: 10 contour lines (upper left), 10 black contour lines (upper right), specified contour levels (lower left), and labeled levels (lower right). label{advancedcontourmatplotlib}

[hpl: Problem: the coordinates are geographical so we should have some `plt.axis('equal')` for every plot in Figure ref{advancedcontourmatplotlib}. Agree? Now the plots are squeezed in $y$ direction and the mountain is not circular.]

===== Vector field plots =====
label{plot:surf:mpl:quiver}

The code for plotting the gradient field (ref{plot:surf:gradient:eq}) together
with contours goes as explained below, once the grid has been defined as in
Section ref{plot:surf:gradient}.
The corresponding plots were shown in Figure ref{plot:surf:mpl:quiver:fig}.

@@@CODE plot3d_matplotlib.py fromto:# Draw contours and gradient field of h@# end draw contours and gradient field of h
The following code plots the normal vector field together with the contours of $h$ in 3D.

@@@CODE plot3d_matplotlib.py fromto:# Draw contours and normal vector field of h@# end draw contours and normal vector field of h
The following code does the same, but replacing the contours with the surface.

@@@CODE plot3d_matplotlib.py fromto:# Draw surface and normal vector field of h@# end draw surface and normal vector field of h
The result was shown in Figure ref{quivercontoursurfmatplotlib}.
Finally the 3D scalar field (ref{plot:surf:3D:surfeq}) and its gradient field
can be plotted as follows, with the grid defined as in Section ref{sec:3Dgradient}
The result was shown in Figure ref{fig:quiver:matplotlib}.

@@@CODE plot3d_matplotlib.py fromto:# Draw 3D vector field with countours of 3D scalar field@# end draw 3D vector field with countours of 3D scalar field
Matplotlib actually lacks functionality for drawing contours of 3D scalar fields,
so here we have improvised by using `ax.plot_surface()` to draw five contours, one at a time.
For the field $g$ we find an expression for each contour by solving $z-h((x,y)=C$.
Here a contour can be plotted as a surface $z=h(x,y)+C$,
but for other 3D scalar fields we do not get so simple expressions for the contours.
Note that we manually set the lengths of the vectors here.

We see that the different surface plots shadow for one-another.
Unfortunately there is no way to make contours visible through each other in Matplotlib.



# #ifdef SCITOOLS_2D3D
======= SciTools =======

SciTools can work with different plotting engines (backends).
Usually, we employ Matplotlib
in the forthcoming figures, but sometimes Gnuplot is required to realize
a certain feature. Below we will use the prefix `plt` for the package `scitools.easyviz`:

!bc pycod
import scitools.easyviz as plt
!ec


===== Surface plots =====

To make the grid, one can either use `meshgrid` as shown above or
`plt.ndgrid` which requires fewer peculiar parameters:

!bc pycod
xv, yv = plt.ndgrid(x, y)       # Grid for contour plot
x2v, y2v = plt.ndgrid(x2, y2)   # Coarser grid for quiver plot
!ec

Surface plots of $h(x,y)$ in (ref{plot:surf:heq}) (colored together with the parameterized curve $\bm{r}(t)$ in (ref{plot:surf:req})) can be produced with `mesh` and `surf` as follows.

[hpl: This is confusing: What does Gnuplot backend as comment mean? The thing is that `mesh` and `surf` are not supported by the Matplotlib interface. Must explain what `mesh` and `surf` etc.]

[or: The matplotlib equivalents of mesh and surf are plotwireframe and plotsurface. Scitools should translate calls to mesh and surf to these for the matplotlib backend. Still this does not seem to work well with, so I use Gnuplot. Should fix with Johannes.
Also, I have not had much luck with the VTK backend]

[or: I changed backend to gnuplot for contour plots, but it seems then that I cannot set the color of the labels anymore, see the plot. I think Scitools is simply not tested enough for 3D here]

@@@CODE plot3d_scitools_gnuplot.py fromto:# Simple plot of mountain@# endsimpleplots

The results are shown in Figure ref{plotscitools}. A Gnuplot backend was used here.

FIGURE:[fig/plot_scitools, height=400 width=600 frac=0.8] Two SciTools surface plots: `mesh` (left) and `surf` (right). The curve $\bm{r}(t)$ is also shown in the right plot. label{plotscitools}



===== Contour plots =====

[hpl: Try to avoid referring to the Matplotlib examples if possible. Just say what you want to plot and show code. Update comments in the code so that they are the same (if possible) for all plotting tools.]

The following code exemplifies how one can create different contour plots with SciTools. As is seen, there are only minor differences in how the parameters (color, levels, labeling) to the plot are set.

@@@CODE plot3d_scitools_gnuplot.py fromto: # Default two-dimensional contour plot@#end contourplots

The first two plots (default two-dimensional and three-dimensional contour plots) are shown in Figure ref{simplecontourscitools}. The next 4 plots are shown in Figure ref{advancedcontourscitools}.

FIGURE:[fig/simple_contour_scitools, height=400 width=600 frac=0.8]  Default two- and three-dimensional contour plots with SciTools. label{simplecontourscitools}

FIGURE:[fig/advanced_contour_scitools, height=400 width=600 frac=0.8] Some other contour plots with SciTools: With 10 contour lines (upper left), with 10 contour lines in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourscitools}



===== Vector field plots =====

There is limited support for plotting three-dimensional vector fields in SciTools (the function is called `contour3`),
so the following code only concerns the gradient field (ref{plot:surf:gradient:eq}).
The code for plotting the gradient field together with contours goes as follows.

@@@CODE plot3d_scitools.py fromto:# Draw contours and gradient field of h@# end draw contours and gradient field of h
The two-dimensional vector field (ref{plot:surf:another:vec:eq}) can be plotted as follows.
[hpl: I don't see why we need a different field here. Why not just plot $\nabla h$ with the commands one wants to illustrate? You seem to want to illustrate
how to set units for the vectors, but that should be explicitly explained
in the text, and I think the example is clearer if we use the same field but
different units or scalings.]

@@@CODE plot3d_scitools.py fromto:# Draw 2D-field@# end draw 2D-field.
The results are shown in Figure ref{quiverscitools}.

FIGURE:[fig/quiver_scitools, height=400 width=600 frac=0.8] Vector field plots with SciTools. Gradient field with contour plot (left). 2D vector field (right). label{quiverscitools}

# #endif

======= Mayavi =======

Mayavi is an advanced, free, easy to use, scientific data visualizer, with an emphasis on three-dimensional visualization techniques.
The package is written in Python, and uses the Visualization Toolkit (VTK) in C++ for rendering graphics. Since VTK can be configured with different backends, so can Mayavi.
Mayavi is cross platform and runs on most platforms, including Mac OS X, Windows, Linux.

The web page URL: "http://docs.enthought.com/mayavi/mayavi/" collects pointers to all relevant documentation of Mayavi.
We shall primarily deal with the
`mayavi.mlab` module, which provides a simple interface to plotting of 2D
scalar and vector fields with commands that mimic those of Matlab.
Let us import this module under our usual name `plt` for a plotting package:

!bc pycod
import mayavi.mlab as plt
!ec

The official documentation of the `mlab` module is provided in two
places, one for the "basic functionality":
"http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html"
and one for "further functionality":
"http://docs.enthought.com/mayavi/mayavi/auto/mlab_other_functions.html".
Basic "figure
handling":"http://docs.enthought.com/mayavi/mayavi/auto/mlab_figure.html"
is very similar to the one we know from Matplotlib.  Just as for
Matplotlib, all plotting commands you do in `mlab` will go into the
same figure, until you manually change to a new figure.


===== Surface plots =====

Mayavi has the functions `mesh` and `surf` for making surface
plots. None of them produce pure wireframe plots, i.e., the faces of
the surface are always colored.  The following code uses these two
functions to plot the surface $h(x,y)$ in (ref{plot:surf:heq}), as
well as the parameterized curve $\bm{r}(t)$ in (ref{plot:surf:req}).
The resulting graphics appears in Figure ref{plotmayavi}.

@@@CODE plot3d_mayavi.py fromto:# Simple plot of mountain@# endsimpleplots
The calls to `plt.figure()` take three parameters: First the usual index for the plot, then two tuples of numbers , representing the RGB-values to be used for the foreground (`fgcolor`) and the background (`bgcolor`).
White and black are  (1,1,1) and (0,0,0), respectively. The foreground color is used for text and labels included in the plot.

The `color` attribute in `plt.surf` adjusts the surface so that it is colored with small variations from the provided base color, here `(.5, .5, .5)`.
Note also the extra parameter `extent`.
Mayavi does no auto-scaling of the axes by default (contrary to Matplotlib),
so if the magnitudes in the vertical and horizontal directions are very different (as they are for $h(x,y)$), the plots may be very concentrated in one direction.
The `extent` parameter ensures that the axes are auto-scaled to fit the contents of the surface.
We will return to what the six values listed in `extent` mean when we have
a more illustrating example.

The command `plot3d` is used to plot the curve $\bm{r}(t)$.  The
attribute `tube_radius` is set to make the curve thicker and more
visible.  Looking at the curve in Figure ref{plotmayavi} (right), we
rather unexpectedly realize that $\bm{r}(t)$ does not lie on the
surface.  The reason is that the ranges of the $x$-, $y$-, and
$z$-values differ for the curve and the surface, so that auto-scaling
will use different scales when placing them on the scene.  We
therefore have to be a bit cautious when applying the auto-scaling in
Mayavi, and in the following contour plots we will avoid this
auto-scaling problem by scaling everything first so that the
coordinates already are of the same order of magnitude.

FIGURE:[fig/plot_mayavi] Two Mayavi surface plots: `mesh` (left) and `surf` (right). The curve $\bm{r}(t)$ is also shown in the right plot. label{plotmayavi}



=== Subplots ===

The two plots in Figure ref{plotmayavi} were created as separate figures. One can also create them as subplots within one figure:

@@@CODE plot3d_mayavi.py fromto:# Create one figure with three subplots@# endsubplot
The result is shown in Figure ref{subplot}.
Three separate `mesh` commands are run, each producing a new plot in the current figure.
The commands use different values for the `colormap` attribute to color the surface in different ways.
When this attribute is not provided, as in the code producing the left plot in Figure ref{plotmayavi}, a default colormap is used.

The `plt.outline` command is used
to create a frame around the subplots, and as seen, we exemplify this possibility
for the last two subplots, but not the first one.
We see that one of the two frames has a different color, obtained by
setting the `color` attribute of the `plt.outline` command.

From the computer code it is hopefully clear that the six values listed in `extent` represent fractions of the cube `(0,1,0,1,0,1)`, where the corresponding plots are placed.
The extents for the three plots are here defined such that they do not overlap.

FIGURE:[fig/subplot, frac=1] A plot with three subplots created with Mayavi. label{subplot}



===== Contour plots =====

The following code exemplifies how one can produce contour plots with
Mayavi.  The code is very similar to that of Matplotlib, but one
difference is that the attribute `contours` now can represent the
number of levels, as well as the levels themselves:

@@@CODE plot3d_mayavi.py fromto:# Default contour plot plotted together with surf@#end contourplots
There is no function in Mayavi which labels the contours.
The plots are shown in Figure ref{advancedcontourmayavi}.

Contour plots in Mayavi are shown in three-dimensional space, but you
can rotate and look at them from above if you want a two-dimensional
plot.  Their visual appearance may be enhanced by also including the
surface plot itself. We have here done this for two of the contour
plots.  There is a clear difference in visual impression between the
two. In the first one, default surface- and contour coloring was used,
resulting in less visible contours.  As we see, the contours are more
visible when a black color is used.

FIGURE:[fig/advanced_contour_mayavi, height=400 width=600 frac=0.8] Some contour plots with Mayavi. label{advancedcontourmayavi}



===== Vector field plots =====
label{plot:surf:mayavi:quiver}

Mayavi supports only vector fields in three-dimensional space.
We will therefore visualize the two-dimensional gradient field (ref{plot:surf:gradient:eq}) by adding a third component of zero.
The following code plots this gradient field  together with the contours of $h$.

@@@CODE plot3d_mayavi_manual.py fromto:# Draw contours and gradient field of h@# end draw contours and gradient field of h
This will produce a 3D view, which we again can rotate to obtain a 2D view.
The result is shown in Figure ref{plot:surf:may:quiver:fig}, which is similar to Figure ref{plot:surf:mpl:quiver:fig}.

FIGURE:[fig/quiver_mayavi_advanced, frac=0.8] Gradient field with contour plot. label{plot:surf:may:quiver:fig}




The following code plots the normal vector field together with the contours of $h$.

@@@CODE plot3d_mayavi.py fromto:# Draw contours and normal vector field of h@# end draw contours and normal vector field of h
The color of the vectors were here set to red, and the attribute `scale_factor` adjusted so that vectors do not collide.
The corresponding plot is shown in Figure ref{quivercontoursurfmayavi}.
Still the plot looks a bit cluttered. If we replace contours with the surface itself, we can use the following code,
which perhaps gives a nicer impression, also shown in Figure ref{quivercontoursurfmayavi}.

FIGURE:[fig/quiver_contour_surf_mayavi, height=400 width=600 frac=1] Normal vector field with contours (left), with surface (right). label{quivercontoursurfmayavi}

@@@CODE plot3d_mayavi.py fromto:# Draw surface and normal vector field of h@# end draw surface and normal vector field of h




[hpl: Maybe skip 3D fields, but say it is a challenging task and a
scientific topic on its own?]
Mayavi has functionality for drawing contours of 3D scalar fields.
The 3D scalar field (ref{plot:surf:3D:surfeq}) and its gradient field
can be plotted together as follows.

@@@CODE plot3d_mayavi.py fromto:# Draw 3D vector field with countours of 3D scalar field@# end draw 3D vector field with countours of 3D scalar field
The result is shown in Figure ref{fig:quiver:mayavi}. This example
demonstrates some of the challenges in plotting three-dimensional vector fields.
The vectors must not be too dense, and not too long.
It is inevitable that contours shadow for one another. Fortunately Mayavi supports an opacity setting, which controls how contours are visible through each other.

FIGURE:[fig/quiver_mayavi, frac=1] The 3D scalar field (ref{plot:surf:3D:surfeq}) and its gradient field. label{fig:quiver:mayavi}

[hpl: No references to Figure ref{fig:quiver:mayavi}.]

















===== Animations =====

[hpl: Emphasize saving figures to file for making videos.]